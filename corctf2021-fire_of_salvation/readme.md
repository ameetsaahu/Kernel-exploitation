```c
struct msg_msg {
	struct list_head m_list;
	long m_type;
	size_t m_ts;		/* message text size */
	struct msg_msgseg *next;
	void *security;
	/* the actual message follows immediately */
};
```
User msg stored right after `msg_msg` structure uptil `0x1000 - 0x30` after that singly linked list of chunks stored in `struct msg_msgseg *next` with size of each allocation upto `0x1000`, is and should be `NULL` terminated.
For arbitrary read:
overwrite `next` and `m_ts` to be such that, it has to read from overwritten `next` pointer.

For arbitrary write:
```c
msgsnd()		// Userland
	do_msgsnd()	// Kernel land
		load_msg()	
			alloc_msg()			// Allocate all the necessary chunks
			copy_from_user()	// Race here to replace `struct msg_msgseg *next` before its used to copy userdata. Maybe use userfaultfd ;)
```
 - [https://blog.hacktivesecurity.com/index.php/2022/06/13/linux-kernel-exploit-development-1day-case-study](https://blog.hacktivesecurity.com/index.php/2022/06/13/linux-kernel-exploit-development-1day-case-study)
 - [https://www.willsroot.io/2021/08/corctf-2021-fire-of-salvation-writeup.html](https://www.willsroot.io/2021/08/corctf-2021-fire-of-salvation-writeup.html)
 - [https://elixir.bootlin.com/linux/v5.8/source/ipc/msg.c#L840](https://elixir.bootlin.com/linux/v5.8/source/ipc/msg.c#L840)